---
title: Improving Expected Points
description: Using Beta calibration to improve the accuracy of expected points in soccer
date: 2023-09-10
draft: true
categories:
  - r
  - soccer
image: footedness_calibration.png
execute: 
  code-fold: false
  eval: false
  include: true
  echo: true
---

## Introduction

This blog post demonstrates how to adjust [expected goals (xG)](https://theanalyst.com/na/2021/07/what-are-expected-goals-xg/) to [more accurately predict](https://www.unofficialgoogledatascience.com/2021/04/why-model-calibration-matters-and-how.html) [match points](https://en.wikipedia.org/wiki/Three_points_for_a_win) for soccer (football) teams. By applying a technique called [calibration](https://en.wikipedia.org/wiki/Calibration_(statistics))[^1], we can better align [**expected points (xPts)**](https://www.bettingodds.com/news/what-are-expected-points-xp-football-betting) with teams' actual performance.

[^1]: or ["remediation"](https://www.tidymodels.org/learn/models/calibration/#remediation)

If you don't care at all about what "expected points" are or simply just want to see how to do such a model calibration with R and [the `{probably}` package](https://probably.tidymodels.org/), feel free to skip past the "Introduction" section.

### Expected Points

In [a prior post](/posts/opta-xg-model-calibration/), I showed how to calculate **expected points (xPts)** from expected goals (xG) for the beautiful game of soccer (football).

::: {.callout-note collapse="true"}
## xG and xPts Definitions

-   **xG** is the predicted probability that a shot will be a goal, based on contextual features like the distance of the shot from the goal.
-   **xPts** is a number between 0 and 3 assigned to each team in a match estimated deterministically from the xG of each shot in the match. Teams that accumulate more xG than their opponents in the match are more likely to have xPts closer to 3.
:::

One thing that is not traditionally accounted for with xG and, consequently, xPts, is [**game state**](https://theathletic.com/2730755/2021/07/28/the-athletics-football-analytics-glossary-explaining-xg-ppda-field-tilt-and-how-to-use-them/), i.e. whether a team is in losing, drawing, or winning when some event (e.g. a shot) occurs. To account for this, we need to make xG "aware" of the game state.

We could add an input feature to the xG model. However:

1.  I'm not the creator of the xG model that I'll be using, so I can't actually do that.
2.  Further, and more importantly, I don't think this is a good idea, based on **conceptual integrity**.

On the latter point--traditional xG models focus on more directly attributable factors such as player positioning and the intrinsic attributes of the shot itself; they remain agnostic to elements like player identity and weather conditions. Sure, we could improve an xG model by having a dummy variable for whether the shot taker is Lionel Messi, but doing so would be shifting away from the intention of a typical xG model.[^2]

[^2]: This isn't to discredit [research](https://statsbomb.com/wp-content/uploads/2022/09/Tahmeed-Tureen-and-Sigrid-Olthof-%E2%80%93-Estimated-Player-Impact-EPI-Quantifying-The-Effects-Of-Individual-Players-On-Football-Actions-Using-Hierarchical-Statistical-Models.pdf) conducted where player effects are modeled as part of xG---I actually really like doing that kind of thing when trying to tease out estimates of player skill. However, for the sole purpose of quantifying the innate quality of a shot, adding inputs that aren't directly related to the attributes of a shot, such as game state, feel unjustified, even if they would improve model performance.

With that being said, when we're applying xG for a separate task, such as for calculating xPts, accounting for game state feels valid. We can do so with a second model that "calibrates" the output of the original model. In this context, we'd aim to align the xG model's output with the actual goal conversion rate, taking into account the game state.[^3]

[^3]: You could also calibrate the output of a model to achieve marginal gains when there are no external factors you want to account for.

So let's dive in.

## Analysis

### Data

We'll be using data from [FBref](https://fbref.com/), which gets its xG from [Opta](https://www.statsperform.com/opta/). We'll limit the scope to the 2017/18 through 2022/23 seasons for the English Premier League. This post isn't about data collection, so I'll skip those details.

Here's a glance at the data frame I'm working with. Note that there is one row per shot.

```{r}
#| label: data-scrape
#| include: false
library(worldfootballR) ## version: 0.6.4.1
library(readr)
library(dplyr)
library(lubridate)
library(tidyr)
library(qs)
library(rlang)
library(purrr)

PROJ_DIR <- 'posts/expected-points-calibration'

load_rds_from_url <- function(url) {
  readRDS(url(url))
}

load_fb_match_summary <- function(item, country, gender, tier, season_end_year) {
  
  urls <- sprintf(
    'https://github.com/JaseZiv/worldfootballR_data/releases/download/fb_match_summary/%s_%s_%s_match_summary.rds',
    country,
    gender,
    tier
  )
  
  purrr::map_dfr(
    urls, 
    load_rds_from_url
  ) |> 
    dplyr::filter(.data$Season_End_Year %in% season_end_year)
}

COUNTRIES <-  'ENG'
GENDERS <- 'M'
TIERS <- '1st'
SEASON_END_YEARS <- 2018:2023

raw_shots <- worldfootballR::load_fb_match_shooting(
  country = COUNTRIES,
  gender = GENDERS,
  tier = TIERS,
  season_end_year = SEASON_END_YEARS
)

raw_match_summaries <- load_fb_match_summary(
  country = COUNTRIES,
  gender = GENDERS,
  tier = TIERS,
  season_end_year = SEASON_END_YEARS
)

extract_fbref_match_id <- function(match_url) {
  basename(dirname(match_url))
}

generate_time_key <- function(period, min, min_added) {
  period * (min + dplyr::coalesce(min_added, 0L))
}

match_summaries <- raw_match_summaries |> 
  dplyr::group_by(MatchURL) |> 
  dplyr::mutate(
    match_summary_rn = dplyr::row_number(dplyr::desc(Event_Time)),
    match_has_no_penalties = all(Event_Type != 'Penalty')
  ) |> 
  dplyr::ungroup() |> 
  dplyr::mutate(
    match_has_no_goals = Away_Score == 0 & Home_Score == 0
  ) |> 
  dplyr::filter(
    Event_Type %in% c('Goal', 'Own Goal', 'Penalty') | 
      ## don't drop games with no goals
      (match_has_no_goals & match_has_no_penalties & match_summary_rn == 1)
  ) |> 
  dplyr::transmute(
    rn = dplyr::row_number(), 
    match_id = extract_fbref_match_id(MatchURL),
    season = sprintf('%s/%s', Season_End_Year - 1, substr(Season_End_Year , 3, 4)),
    gender = Gender,
    tier = Tier,
    date = lubridate::ymd(Match_Date),
    home_team = Home_Team ,
    away_team = Away_Team,
    period = as.integer(Event_Half),
    min = dplyr::case_when(
      period == 1L & Event_Time > 45 ~ 45, 
      period == 2L & Event_Time > 90 ~ 90,
      .default = Event_Time
    ) |> as.integer(),
    min_added = dplyr::case_when(
      period == 1L & Event_Time > 45 ~ Event_Time - 45, 
      period == 2L & Event_Time > 90 ~ Event_Time - 90,
      .default = NA_integer_
    ) |> as.integer(),
    final_home_g = Home_Score,
    final_away_g = Away_Score,
    home_g = as.integer(gsub('[:].*$', '', Score_Progression)), ## after event
    away_g = as.integer(gsub('^.*[:]', '', Score_Progression)),
    match_has_no_goals,
    match_has_no_penalties,
    is_own_goal = Event_Type == 'Own Goal',
    is_penalty = Event_Type == 'Penalty',
    team = Team,
    player = Event_Players,
    event_type = ifelse(match_has_no_goals & match_has_no_penalties, NA_character_, Event_Type),
    time_key = generate_time_key(period, min, min_added)
  )

match_results <- match_summaries |> 
  dplyr::distinct(
    match_id,
    season,
    gender,
    tier,
    date,
    home_team,
    away_team,
    home_g = final_home_g,
    away_g = final_away_g
  )
qs::qsave(match_results, file.path(PROJ_DIR, 'match_results.qs'))

long_shots <- raw_shots |> 
  dplyr::transmute(
    rn = dplyr::row_number(),
    match_id = extract_fbref_match_id(MatchURL),
    period = as.integer(Match_Half),
    min = ifelse(
      grepl('[+]', Minute),
      as.integer(gsub('(^[0-9]+)[+]([0-9]+$)', '\\1', Minute)), 
      as.integer(Minute)
    ),
    min_added = ifelse(
      grepl('[+]', Minute), 
      as.integer(gsub('(^[0-9]+)[+]([0-9]+$)', '\\2', Minute)), 
      NA_integer_
    ),
    is_home = Home_Away == 'Home',
    team = Squad,
    player = Player,
    is_goal = Outcome == 'Goal',
    xg = as.double(xG),
    is_penalty = dplyr::coalesce((Distance == '13' & round(xg, 2) == 0.79), FALSE),
    time_key = generate_time_key(period, min, min_added)
  )

synthetic_rn_base <- 10^(ceiling(log10(max(long_shots$rn))))
long_shots_with_own_goals <- long_shots |> 
  dplyr::mutate(
    is_own_goal = FALSE
  ) |> 
  dplyr::bind_rows(
    ## synthetic events for own goals
    match_summaries |> 
      dplyr::filter(
        is_own_goal
      ) |> 
      dplyr::transmute(
        rn = .env$synthetic_rn_base + dplyr::row_number(),
        match_id,
        period,
        min,
        min_added,
        is_home = team == home_team,
        team,
        player,
        is_goal = TRUE,
        xg = NA_real_,
        time_key,
        is_own_goal = TRUE,
        is_penalty = FALSE
      )
  )
clean_shots <- long_shots_with_own_goals |> 
  dplyr::inner_join(
    match_summaries |>
      dplyr::distinct(match_id, season, date, home_team, away_team),
    by = dplyr::join_by(match_id),
    relationship = 'many-to-one'
  ) |> 
  dplyr::left_join(
    match_summaries |> 
      dplyr::group_by(match_id, time_key) |> 
      dplyr::slice_max(home_g + away_g, n = 1, with_ties = FALSE) |> 
      dplyr::ungroup() |>
      dplyr::select(
        match_id, 
        time_key, 
        home_g, 
        away_g,
        is_own_goal,
        is_penalty,
        team,
        player
      ) |> 
      dplyr::rename_with(
        \(.x) paste0('summary_', .x),
        -c(match_id)
      ),
    by = dplyr::join_by(
      match_id,
      time_key >= summary_time_key,
      time_key <= summary_time_key
    ),
    relationship = 'many-to-many'
  ) |> 
  dplyr::group_by(match_id) |> 
  tidyr::fill(summary_home_g, summary_away_g, .direction = 'down') |> 
  dplyr::ungroup() |> 
  dplyr::mutate(
    dplyr::across(c(summary_home_g, summary_away_g), \(.x) dplyr::coalesce(.x, 0L))
  ) |> 
  dplyr::mutate(
    home_g = dplyr::case_when(
      ## note that fotmob would list the away team for an own goal but fbref lists the home team
      (is_goal | is_own_goal) & is_home ~ 1L,
      is_own_goal & is_home ~ 1L,
      TRUE ~ 0L
    ),
    away_g = dplyr::case_when(
      (is_goal | is_own_goal) & !is_home ~ 1L,
      TRUE ~ 0L
    ),
    home_xg = dplyr::case_when(
      is_home ~ dplyr::coalesce(xg, 0),
      TRUE ~ 0L ## even for own goals
    ),
    away_xg = dplyr::case_when(
      !is_home ~ dplyr::coalesce(xg, 0),
      TRUE ~ 0L
    )
  ) |>
  dplyr::group_by(match_id) |> 
  dplyr::mutate(
    shot_idx = dplyr::row_number(time_key)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::mutate(
    shot_id = sprintf('%s-%02d', match_id, shot_idx)
  ) |> 
  dplyr::arrange(season, date, shot_id)

restacked_shots <- dplyr::bind_rows(
  clean_shots |> 
    dplyr::filter(is_home) |> 
    dplyr::transmute(
      shot_id,
      match_id,
      season,
      date,
      period,
      min,
      min_added,
      is_home,
      is_goal,
      is_penalty,
      is_own_goal,
      player,
      team = home_team,
      opponent = away_team,
      g = home_g,
      g_conceded = away_g,
      xg = home_xg,
      xg_conceded = away_xg,
      summary_g = summary_home_g,
      summary_g_conceded = summary_away_g
    ),
  clean_shots |> 
    dplyr::filter(!is_home) |> 
    dplyr::transmute(
      shot_id,
      match_id,
      season,
      date,
      period,
      min,
      min_added,
      is_home,
      is_goal,
      is_penalty = summary_is_penalty,
      is_own_goal,
      player,
      team = away_team,
      opponent = home_team,
      g = away_g,
      g_conceded = home_g,
      xg = away_xg,
      xg_conceded = home_xg,
      summary_g = summary_away_g,
      summary_g_conceded = summary_home_g,
    )
) |> 
  dplyr::arrange(season, date, match_id, shot_id)

doublecounted_restacked_shots <- dplyr::bind_rows(
  restacked_shots |> dplyr::mutate(pov = 'primary', .before = is_home),
  restacked_shots |> 
    dplyr::rename(
      team1 = team,
      team2 = opponent,
      g1 = g,
      g2 = g_conceded,
      xg1 = xg,
      xg2 = xg_conceded
    ) |> 
    dplyr::rename(
      team = team2,
      opponent = team1,
      g = g2,
      g_conceded = g1,
      xg = xg2,
      xg_conceded = xg1
    ) |> 
    dplyr::mutate(
      is_home = !is_home,
      pov = 'secondary'
    )
) |> 
  dplyr::arrange(season, date, match_id, shot_id, pov)

cumu_doublecounted_restacked_shots <- doublecounted_restacked_shots |> 
  dplyr::group_by(match_id, team) |> 
  dplyr::mutate(
    dplyr::across(
      c(g, g_conceded, xg, xg_conceded),
      list(cumu = cumsum)
    )
  ) |> 
  dplyr::ungroup() |> 
  dplyr::mutate(
    is_goal = factor(ifelse(g == 1L, 'yes', 'no')),
    game_state = g_cumu - g_conceded_cumu
  )
qs::qsave(cumu_doublecounted_restacked_shots, file.path(PROJ_DIR, 'shots.qs'))
```

```{r}
#| label: shots
#| include: false
library(dplyr)
library(qs)
library(purrr)
library(probably)
# packageVersion('probably')  ## 1.0.1.9000

library(ggplot2)
library(sysfonts)
library(showtext)
library(ggtext)
library(ragg)
library(htmltools)

match_results <- qs::qread(file.path(PROJ_DIR, 'match_results.qs'))
raw_shots <- qs::qread(file.path(PROJ_DIR, 'shots.qs')) |> 
  dplyr::filter(
    pov == 'primary',
    !is_own_goal
  )

ORDERED_GAME_STATE_LABELS <- c('trailing', 'neutral', 'leading')
shots <- raw_shots |> 
  dplyr::inner_join(
    match_results |> 
      dplyr::distinct(
        match_id,
        home_team,
        away_team
      ),
    by = dplyr::join_by(match_id)
  ) |> 
  dplyr::transmute(
    match_id,
    season,
    date,
    home_team,
    away_team,
    team,
    player,
    shot_id,
    is_penalty,
    is_goal,
    .pred_yes = xg,
    .pred_no = 1 - xg,
    game_state = cut(
      game_state,
      breaks = c(-Inf, -1, 0, Inf), 
      labels = ORDERED_GAME_STATE_LABELS
    )
  ) |> 
  dplyr::group_by(match_id) |> 
  dplyr::arrange(shot_id, .by_group = TRUE) |> 
  dplyr::mutate(
    pre_shot_game_state = dplyr::lag(game_state, default = 'neutral')
  ) |> 
  dplyr::ungroup()
```

```{r}
#| label: shots-show
#| code-fold: false
library(dplyr)
shots |> 
  dplyr::select(
    shot_id,
    team,
    player,
    is_goal,
    pre_shot_game_state,
    .pred_yes, ## xg
    .pred_no   ## 1 - xg
  )

#> # A tibble: 56,872 × 7
#>    shot_id     team     player is_goal pre_shot_game_state .pred_yes .pred_no
#>    <chr>       <chr>    <chr>  <fct>   <fct>                   <dbl>    <dbl>
#>  1 0014076a-01 Arsenal  Henri… no      neutral                  0.03     0.97
#>  2 0014076a-02 Arsenal  Henri… no      neutral                  0.06     0.94
#>  3 0014076a-03 West Ha… Marko… no      neutral                  0.08     0.92
#>  4 0014076a-04 West Ha… Marko… no      neutral                  0.03     0.97
#>  5 0014076a-05 West Ha… Marko… yes     neutral                  0.05     0.95
#>  6 0014076a-06 Arsenal  Aaron… no      leading                  0.11     0.89
#>  7 0014076a-07 Arsenal  Nacho… yes     trailing                 0.6      0.4 
#>  8 0014076a-08 West Ha… Micha… no      neutral                  0.07     0.93
#>  9 0014076a-09 West Ha… Felip… no      neutral                  0.07     0.93
#> 10 0014076a-10 Arsenal  Shkod… no      neutral                  0.02     0.98
#> # ℹ 56,862 more rows
```

::: {.callout-note collapse="false"}
## `shots` Data Dictionary

While several of these columns should be self-explanatory, e.g. `team` and `player`, some could use an explanation:

-   `.pred_yes`: xG[^4]
-   `.pred_no`: 1 minus xG
-   `pre_shot_game_state`: whether the team of the player taking the shot was winning (`"leading"`), drawing (`"neutral"`), or losing (`"trailing"`) the match before the shot was taken[^5]
:::

[^4]: I've found that `{probably}` needs a column for both the probability of "success" and "failure", hence the seeming redundancy between `.pred_yes` and `.pred_no`. More broadly, these column names should correspond with `{.pred}_{level1}` and `.pred_{level2}` for binary classification, where the target variable has factor levels `{level1}` and `{level2}`. (`{tidymodels}` expects the target variable to be a factor.)

[^5]: I intentionally emphasize that the game state feature is with respect to the score prior to the outcome of the shot. It would be easy to calculate game state based on the score after the outcome of a shot, but that would be ["leaking"](https://www.kaggle.com/code/alexisbcook/data-leakage) information that could artificially enhance the model calibration.

Let's start by taking a look at the calibration of the Opta xG model, splitting by game state. (Note that this uses `probably::cal_plot_breaks()`.)

```{r}
#| label: no_pre_shot_game_state_xg_calibration
#| include: false
library(purrr)
library(probably)
# packageVersion('probably') ## 0.1.0.9008

library(ggplot2)
library(sysfonts)
library(showtext)
library(ggtext)
library(htmltools)

CAL_N_BREAKS <- 20
CAL_CONF_LEVEL <- 0.9

TAG_LABEL <- htmltools::tagList(
  htmltools::tags$span(htmltools::HTML(enc2utf8("&#xf099;")), style = 'font-family:fb'),
  htmltools::tags$span("@TonyElHabr"),
)
CAPTION_LABEL <- '**Data**: Opta via fbref.<br/>Point size is proportional to number of observations.'
SUBTITLE_LABEL <- 'English Premier League, 2017/18 - 2022/23'
PLOT_RESOLUTION <- 300
WHITISH_FOREGROUND_COLOR <- 'white'
COMPLEMENTARY_FOREGROUND_COLOR <- '#f1f1f1'
BLACKISH_BACKGROUND_COLOR <- '#1c1c1c'
COMPLEMENTARY_BACKGROUND_COLOR <- '#4d4d4d'
FONT <- 'Titillium Web'
sysfonts::font_add_google(FONT, FONT)
## https://github.com/tashapiro/tanya-data-viz/blob/main/chatgpt-lensa/chatgpt-lensa.R for twitter logo
sysfonts::font_add('fb', 'Font Awesome 6 Brands-Regular-400.otf')
showtext::showtext_auto()
showtext::showtext_opts(dpi = PLOT_RESOLUTION)

ggplot2::theme_set(ggplot2::theme_minimal())
ggplot2::theme_update(
  text = ggplot2::element_text(family = FONT),
  title = ggplot2::element_text(size = 20, color = WHITISH_FOREGROUND_COLOR),
  plot.title = ggtext::element_markdown(face = 'bold', size = 20, color = WHITISH_FOREGROUND_COLOR),
  plot.title.position = 'plot',
  plot.subtitle = ggtext::element_markdown(size = 16, color = COMPLEMENTARY_FOREGROUND_COLOR),
  axis.text = ggplot2::element_text(color = WHITISH_FOREGROUND_COLOR, size = 14),
  # axis.title = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),
  axis.title.x = ggtext::element_markdown(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),
  axis.title.y = ggtext::element_markdown(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),
  axis.line = ggplot2::element_blank(),
  strip.text = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0),
  panel.grid.major = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),
  panel.grid.minor = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),
  panel.grid.minor.x = ggplot2::element_blank(),
  panel.grid.minor.y = ggplot2::element_blank(),
  plot.margin = ggplot2::margin(10, 20, 10, 20),
  plot.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR),
  plot.caption = ggtext::element_markdown(color = WHITISH_FOREGROUND_COLOR, hjust = 0, size = 10, face = 'plain'),
  plot.caption.position = 'plot',
  plot.tag = ggtext::element_markdown(size = 12, color = WHITISH_FOREGROUND_COLOR, hjust = 1),
  plot.tag.position = c(0.99, 0.01),
  panel.spacing.x = grid::unit(2, 'lines'),
  panel.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR)
)
ggplot2::update_geom_defaults('text', list(color = WHITISH_FOREGROUND_COLOR, size = 12 / .pt))
ggplot2::update_geom_defaults('point', list(color = WHITISH_FOREGROUND_COLOR))

plot_and_save_calibration <- function(
    df,
    .by,
    size = 7,
    width = size, 
    height = size, 
    title = NULL,
    caption = NULL,
    filename = tempfile(),
    extra_layers
) {
  
  group_cols <- rlang::ensyms(.by)
  
  p <- df |> 
    ggplot2::ggplot() +
    ggplot2::aes(x = predicted_midpoint, y = event_rate) +
    ggplot2::geom_abline(color = WHITISH_FOREGROUND_COLOR, linetype = 2) +
    ggplot2::geom_ribbon(
      fill = '#999999',
      alpha = 0.5,
      ggplot2::aes(ymin = lower, ymax = upper)
    ) +
    ggplot2::geom_line(color = WHITISH_FOREGROUND_COLOR) +
    ggplot2::geom_point(
      color = WHITISH_FOREGROUND_COLOR,
      ggplot2::aes(size = total),
      show.legend = FALSE
    ) +
    ggplot2::coord_cartesian(
      xlim = c(0, 1),
      ylim = c(0, 1)
    ) +
    ggplot2::labs(
      title = paste0(c('xG calibration', title), collapse = ' by '),
      subtitle = SUBTITLE_LABEL,
      y = 'Actual goal rate',
      x = 'Expected goals (xG)',
      caption = paste0(c(CAPTION_LABEL, caption), collapse = '<br/>'),
      tag = TAG_LABEL
    ) + 
    ggplot2::theme(
      panel.grid.major = ggplot2::element_blank(),
      panel.background = ggplot2::element_rect(color = WHITISH_FOREGROUND_COLOR)
    ) + 
    ggplot2::facet_wrap(ggplot2::vars(!!!group_cols))
  
  if (isFALSE(missing(extra_layers))) {
    p <- p + extra_layers
  }
  
  ggplot2::ggsave(
    p,
    filename = file.path(PROJ_DIR, sprintf('%s_calibration.png', filename)),
    width = width,
    height = height
  )
  invisible(p)
}

xg_cal_plot_breaks <- purrr::partial(
  probably::cal_plot_breaks,
  num_breaks = CAL_N_BREAKS,
  conf_level = CAL_CONF_LEVEL,
  event_level = 'second'
)

extra_xg_cal_plot_layers <- list(
  ggplot2::geom_segment(
    data = data.frame(
      x = 0.45,
      xend = 0.35,
      y = 0.6,
      yend = 0.7,
      pre_shot_game_state = 'leading'
    ),
    arrow = grid::arrow(length = grid::unit(6, 'pt'), type = 'closed'),
    ggplot2::aes(
      x = x,
      xend = xend,
      y = y,
      yend = yend
    ),
    linewidth = 1,
    color = '#009ffd'
  ),
  ggplot2::geom_segment(
    data = data.frame(
      x = 0.55,
      xend = 0.65,
      y = 0.4,
      yend = 0.3,
      pre_shot_game_state = 'leading'
    ),
    arrow = grid::arrow(length = grid::unit(6, 'pt'), type = 'closed'),
    ggplot2::aes(
      x = x,
      xend = xend,
      y = y,
      yend = yend
    ),
    linewidth = 1,
    color = '#ffa400'
  ),
  ggtext::geom_richtext(
    data = data.frame(
      x = 0.65,
      y = 0.8,
      label = 'Model *under-predicts*',
      pre_shot_game_state = 'leading'
    ),
    fill = NA, label.color = NA,
    label.padding = grid::unit(rep(0, 1), 'pt'),
    color = '#009ffd',
    family = FONT,
    hjust = 1,
    vjust = 0.5,
    size = 12 / ggplot2::.pt,
    ggplot2::aes(
      x = x,
      y = y,
      label = label
    )
  ),
  ggtext::geom_richtext(
    data = data.frame(
      x = 0.35,
      y = 0.2,
      label = 'Model *over-predicts*',
      pre_shot_game_state = 'leading'
    ),
    fill = NA, label.color = NA,
    label.padding = grid::unit(rep(0, 1), 'pt'),
    color = '#ffa400',
    family = FONT,
    hjust = 0,
    vjust = 0.5,
    size = 12 / ggplot2::.pt,
    ggplot2::aes(
      x = x,
      y = y,
      label = label
    )
  )
)

calib_game_state <- shots |> 
  xg_cal_plot_breaks(
    truth = is_goal,
    estimate = .pred_yes,
    .by = pre_shot_game_state
  ) |> 
  purrr::pluck('data')

plot_and_save_calibration(
  calib_game_state,
  width = 9,
  height = 9 / 2,
  extra_layers = extra_xg_cal_plot_layers,
  .by = pre_shot_game_state,
  caption = sprintf('Ribbon shows %s%% confidence interval', round(100 * CAL_CONF_LEVEL)),
  title = 'game state',
  filename = 'no_pre_shot_game_state_xg'
)
```

![](no_pre_shot_game_state_xg_calibration.png)

### Calibration Modeling

Now we **train** a model for calibration, grouping based on game state. (Well, really there are three models, one for each level of `pre_shot_game_state`.) I've opted for [Beta calibration](https://probably.tidymodels.org/reference/cal_estimate_beta.html) over alternatives like [logistic calibration](https://probably.tidymodels.org/reference/cal_estimate_logistic.html). Beta calibration [tends to provide superior probability estimates](https://projecteuclid.org/journals/electronic-journal-of-statistics/volume-11/issue-2/Beyond-sigmoids--How-to-obtain-well-calibrated-probabilities-from/10.1214/17-EJS1338SI.full), especially with skewed data like xG, where most values tend towards 0.

```{r}
#| label: shot-adjustment
#| include: false
## probably has a bug when .by is a factor? (https://github.com/tidymodels/probably/issues/127)
shots$pre_shot_game_state <- as.character(shots$pre_shot_game_state)
```

```{r}
#| label: beta_cal_model
#| code-fold: false
library(probably)

beta_cal_model <- probably::cal_estimate_beta(
  shots,
  truth = is_goal,
  estimate = dplyr::starts_with('.pred'),
  .by = pre_shot_game_state
)
beta_cal_model
#> ── Probability Calibration 
#> Method: Beta calibration
#> Type: Binary
#> Source class: Data Frame
#> Data points: 56,872, split in 3 groups
#> Truth variable: `is_goal`
#> Estimate variables:
#> `.pred_no` ==> no
#> `.pred_yes` ==> yes
```

::: {.callout-note collapse="true"}
## How `{probably}` Implements Beta Calibration

At time of writing, this is implemented like so "under the hood".

```{r}
#| label: beta_cal_model-details
#| code-fold: false
library(purrr)
library(betacal)
library(rlang) ## for .env and .data

purrr::map(
  unique(shots$pre_shot_game_state),
  function(pre_shot_game_state) {
    filt_shots <- dplyr::filter(
      shots,
      .data$pre_shot_game_state == .env$pre_shot_game_state
    )
    betacal::beta_calibration(
      p = filt_shots$.pred_no,
      y = filt_shots$is_goal == 'no',
      parameters = 'abm'
    )
  }
)
```

As we can see, there's just one dependent variable! After all, calibration is pretty straightforward--we leverage the original model output and the known target label to improve the model output.
:::

```{r}
#| label: beta_cal_calib_game_state
#| include: false
beta_cal_calib_game_state <- beta_cal_shots |>
  xg_cal_plot_breaks(
    truth = is_goal,
    estimate = .pred_yes,
    .by = pre_shot_game_state
  ) |> 
  purrr::pluck('data')
```

::: {.callout-note collapse="true"}
## Calibration Without a Grouping Variable

Taking one step back, I should note that we could achieve better model performance compared to raw xG ***without*** accounting for a "grouping" variable, e.g. game state. Indeed, this is what is typically meant with calibration. By definition, calibration is

$$
\hat{p} = \Pr(Y|\hat{p})
$$ {#eq-calibration}

where $Y$ is the target variable of interest, and $\hat{p}$ is the predicted probability of our classification model. (Note no exogenous variables.) Implementation-wise, we'd just take out the `.by` variable to our call to `probably::cal_estimate_beta()`.

```{r}
#| label: cal_estimate_beta
#| code-fold: false
probably::cal_estimate_beta(
  shots,
  truth = is_goal,
  estimate = dplyr::starts_with('.pred')
)
```
:::

With the fitted calibration models, let's **apply** the Beta calibration procedure to our shots data set.

```{r}
#| label: beta_cal_shots
#| code-fold: false
beta_cal_shots <- probably::cal_apply(
  shots,
  beta_cal_model
)
```

Below is a plot that shows how the Beta calibration has adjusted the raw **"uncalibrated"** xG values.

```{r}
#| label: compared_cal_shots_plot
#| include: false
#| 
shots$pre_shot_game_state <- factor(
  shots$pre_shot_game_state, 
  levels = ORDERED_GAME_STATE_LABELS
)

beta_cal_shots$pre_shot_game_state <- factor(
  beta_cal_shots$pre_shot_game_state, 
  levels = ORDERED_GAME_STATE_LABELS
)

cal_shots <- dplyr::inner_join(
  shots,
  beta_cal_shots |> 
    dplyr::select(shot_id, starts_with('.pred')) |> 
    dplyr::rename_with(
      \(.x)  gsub('.pred', '.cal_pred', .x), 
      dplyr::starts_with('.pred')
    ),
  by = dplyr::join_by(shot_id)
)

cal_shots_plot <- cal_shots |>
  ggplot2::ggplot() +
  ggplot2::aes(x = .pred_yes, y = .cal_pred_yes) +
  ggplot2::geom_abline(color = WHITISH_FOREGROUND_COLOR, linetype = 2) +
  ggplot2::geom_point(
    color = WHITISH_FOREGROUND_COLOR,
    shape = 21,
    show.legend = FALSE
  ) +
  ggplot2::coord_cartesian(
    xlim = c(0, 1),
    ylim = c(0, 1)
  ) +
  ggplot2::facet_wrap(~pre_shot_game_state) +
  ggplot2::labs(
    title = '<span style=color:#F012BE>Uncalibrated</span> vs. <span style=color:#FFDC00>Calibrated</span> xG',
    subtitle = SUBTITLE_LABEL,
    y = '<span style=color:#FFDC00>Calibrated</span> xG',
    x = '<span style=color:#F012BE>Uncalibrated</span> xG',
    caption = '<br/>',
    tag = TAG_LABEL
  ) +
  ggplot2::theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.background = ggplot2::element_rect(color = WHITISH_FOREGROUND_COLOR)
  )

ggplot2::ggsave(
  cal_shots_plot,
  filename = file.path(PROJ_DIR, 'uncalibrated_vs_calibrated_xg.png'),
  width = 9,
  height = 9 / 2
)
```

![](uncalibrated_vs_calibrated_xg.png)

Putting the **calibrated** xG along side the original xG in the calibration plot that we made earlier, we can see a slight visual improvement.

```{r}
#| label: calib_game_state_plot
#| include: false
beta_cal_calib_game_state <- beta_cal_shots |>
  xg_cal_plot_breaks(
    truth = is_goal,
    estimate = .pred_yes,
    .by = pre_shot_game_state
  ) |> 
  purrr::pluck('data')

stacked_calib_game_state <- dplyr::bind_rows(
  calib_game_state |> dplyr::mutate(method =  'Uncalibrated'),
  beta_cal_calib_game_state |> dplyr::mutate(method = 'Calibrated')
) |> 
  dplyr::mutate(method = factor(method, c('Uncalibrated', 'Calibrated')))

compared_calib_plot <- stacked_calib_game_state |> 
  ggplot2::ggplot() +
  ggplot2::aes(x = predicted_midpoint, y = event_rate, color = method) +
  ggplot2::geom_abline(color = WHITISH_FOREGROUND_COLOR, linetype = 2) +
  ggplot2::geom_line(
    alpha = 0.5,
    ggplot2::aes(y = event_rate),
    show.legend = FALSE
  ) +
  ggplot2::geom_point(
    alpha = 1,
    ggplot2::aes(y = event_rate, size = total),
    show.legend = FALSE
  ) +
  ggplot2::coord_cartesian(
    xlim = c(0, 1),
    ylim = c(0, 1)
  ) +
  ggplot2::scale_color_manual(
    values = c('Uncalibrated' = '#F012BE', 'Calibrated' = '#FFDC00')
  ) +
  ggplot2::labs(
    title = 'Comparing Performance of <span style=color:#F012BE>Uncalibrated</span> vs. <span style=color:#FFDC00>Calibrated</span> xG',
    subtitle = SUBTITLE_LABEL,
    y = 'Actual goal rate',
    x = 'Expected goals (xG)',
    caption = CAPTION_LABEL,
    tag = TAG_LABEL
  ) + 
  ggplot2::theme(
    legend.position = 'top',
    panel.grid.major = ggplot2::element_blank(),
    panel.background = ggplot2::element_rect(color = WHITISH_FOREGROUND_COLOR)
  ) + 
  ggplot2::facet_wrap(ggplot2::vars(pre_shot_game_state))  + 
  ggtext::geom_richtext(
    data = data.frame(
      x = 0.05,
      y = 0.9,
      label = '<span style=color:#F012BE>Uncalibrated xG</span><br/><span style=color:#FFDC00>Calibrated xG</span>',
      pre_shot_game_state = 'neutral'
    ),
    fill = NA, label.color = NA,
    label.padding = grid::unit(rep(0, 1), 'pt'),
    family = FONT,
    hjust = 0,
    vjust = 0.5,
    size = 11 / ggplot2::.pt,
    inherit.aes = FALSE,
    ggplot2::aes(
      x = x,
      y = y,
      label = label
    )
  )

ggplot2::ggsave(
  compared_calib_plot,
  filename = file.path(PROJ_DIR, 'compared_calibration.png'),
  width = 9,
  height = 9 / 2
)
```

![](compared_calibration.png)

We could evaluate just how much the calibration has helped by calculating [Brier Skill Score](https://en.wikipedia.org/wiki/Brier_score#Brier_Skill_Score_(BSS)), for example, but quantifying improvement to xG is not our primary focus.

### Revising Expected Points (xPts)

We set out to evaluate how we could improve xPts (which relies on xG), so let's do that. I'll spare the details of how to calculate xPts because I have a whole separate blog post on that.

```{r}
#| label: expected-points-calc
#| include: false
library(purrr)
library(poibin)
library(gdata)

permute_xg <- function(xg) {
  n <- length(xg)
  x <- seq.int(0, n)
  poibin::dpoibin(x, xg)
}

calculate_permuted_xg <- function(df) {
  df |> 
    dplyr::group_by(dplyr::across(c(tidyselect::vars_select_helpers$everything(), -xg))) |> 
    dplyr::summarize(dplyr::across(xg, ~list(.x))) |> 
    dplyr::mutate(
      prob = purrr::map(xg, ~permute_xg(.x))
    ) |> 
    dplyr::select(-c(xg)) |> 
    tidyr::unnest(cols = c(prob)) |> 
    dplyr::group_by(dplyr::across(-c(prob))) |>
    dplyr::mutate(
      g = dplyr::row_number() - 1L
    ) |>
    dplyr::ungroup() |> 
    dplyr::arrange(match_id, is_home)
}

summarize_pivoted_permuted_xg <- function(prob_away, prob_home) {
  outer_prod <- outer(prob_away, prob_home)
  p_draw <- sum(diag(outer_prod), na.rm = TRUE)
  p_home <- sum(gdata::upperTriangle(outer_prod), na.rm = TRUE)
  p_away <- sum(gdata::lowerTriangle(outer_prod), na.rm = TRUE)
  list(
    draw = p_draw,
    home = p_home,
    away = p_away
  )
}

## Bournemouth 0 - 1 Manchester City on 2019-03-02
## Huddersfield 0 - 0 Swansea on 2018-03-10
pad_for_matches_without_shots_from_one_team <- function(df) {
  n_teams_per_match <- df |> 
    dplyr::distinct(match_id, team) |> 
    dplyr::count(match_id, sort = TRUE)
  
  matches_with_no_shots_from_one_team <- n_teams_per_match |> 
    dplyr::filter(n == 1)
  
  dummy_opponents <- df |> 
    dplyr::distinct(match_id, season, date, team, opponent, is_home) |> 
    dplyr::semi_join(
      matches_with_no_shots_from_one_team,
      by = dplyr::join_by(match_id)
    ) |> 
    dplyr::mutate(
      dummy_team = team
    ) |> 
    dplyr::transmute(
      match_id, 
      season, 
      date, 
      team = opponent,
      opponent = dummy_team,
      dplyr::across(is_home, ~!.x),
      prob = 1,
      g = 0L
    )
  
  dplyr::bind_rows(
    df,
    dummy_opponents
  ) |> 
    dplyr::arrange(season, date, team, g)
}

summarize_permuted_xg_by_match <- function(df) {
  
  padded_df <- pad_for_matches_without_shots_from_one_team(df)
  
  pivoted <- padded_df |>
    dplyr::transmute(
      match_id,
      season,
      date,
      g,
      is_home = ifelse(is_home, 'home', 'away'),
      prob
    ) |>
    tidyr::pivot_wider(
      names_from = is_home,
      names_prefix = 'prob_',
      values_from = prob,
      values_fill = 0L
    )
  
  pivoted |> 
    dplyr::select(match_id, season, date, prob_away, prob_home) |>
    dplyr::group_by(match_id, season, date) |> 
    dplyr::summarize(
      dplyr::across(dplyr::starts_with('prob_'), ~list(.x))
    ) |> 
    dplyr::ungroup() |> 
    dplyr::inner_join(
      padded_df |> dplyr::distinct(match_id, team, opponent, is_home),
      by = 'match_id'
    ) |> 
    dplyr::mutate(
      prob = map2(prob_away, prob_home, summarize_pivoted_permuted_xg)
    ) |> 
    dplyr::select(-starts_with('prob_')) |> 
    tidyr::unnest_wider(prob, names_sep = '_') |> 
    dplyr::mutate(
      prob_win = ifelse(is_home, prob_home, prob_away),
      prob_lose = ifelse(is_home, prob_away, prob_home),
      xpts = 3 * prob_win + 1 * prob_draw
    ) |> 
    dplyr::select(-c(prob_home, prob_away))
}

calculate_xpts_by_match <- purrr::compose(
  \(df) {
    dplyr::select(
      df,
      match_id,
      season,
      date,
      is_home,
      team,
      opponent,
      xg
    )
  },
  calculate_permuted_xg,
  summarize_permuted_xg_by_match,
  .dir = 'forward'
)

reg_xpts_by_match <- calculate_xpts_by_match(raw_shots)

cal_xpts_by_match <- cal_shots |> 
  dplyr::select(
    shot_id,
    xg = .cal_pred_yes
  ) |> 
  dplyr::inner_join(
    raw_shots |> dplyr::select(-xg),
    by = join_by(shot_id)
  ) |> 
  calculate_xpts_by_match()

match_results <- qs::qread(file.path(PROJ_DIR, 'match_results.qs'))
match_pts <- dplyr::bind_rows(
  match_results |> 
    dplyr::transmute(
      match_id,
      season,
      gender,
      tier,
      date,
      is_home = TRUE,
      team = home_team,
      opponent = away_team,
      g = home_g,
      g_conceded = away_g
    ),
  match_results |> 
    dplyr::transmute(
      match_id,
      season,
      gender,
      tier,
      date,
      is_home = FALSE,
      team = away_team,
      opponent = home_team,
      g = away_g,
      g_conceded = home_g
    ) 
) |> 
  dplyr::ungroup() |> 
  dplyr::mutate(
    result = dplyr::case_when(
      g > g_conceded ~ 'w',
      g < g_conceded ~ 'l',
      g == g_conceded ~ 'd'
    ),
    is_win = g > g_conceded,
    is_draw = g == g_conceded
  ) |> 
  dplyr::transmute(
    match_id,
    team,
    result,
    pts = 3 * as.integer(is_win) + 1 * as.integer(is_draw)
  )

compared_xpts_by_match <- reg_xpts_by_match |> 
  dplyr::rename_with(
    \(.x) paste0('reg_', .x),
    c(xpts, tidyselect::vars_select_helpers$starts_with('prob'))
  ) |> 
  dplyr::inner_join(
    cal_xpts_by_match |>
      dplyr::select(match_id, team, xpts, tidyselect::vars_select_helpers$starts_with('prob')) |> 
      dplyr::rename_with(
        \(.x) paste0('cal_', .x),
        c(xpts, tidyselect::vars_select_helpers$starts_with('prob'))
      ),
    by = dplyr::join_by(match_id, team)
  ) |> 
  dplyr::inner_join(
    match_pts,
    by = dplyr::join_by(match_id, team)
  )
```

Instead, let's skip to evaluating

```{r}
#| label: compared_xpts_by_match_plot
#| include: false
compared_xpts_by_match_plot <- compared_xpts_by_match |> 
  ggplot2::ggplot() +
  ggplot2::aes(
    x = reg_xpts,
    y = cal_xpts
  ) +
  ggplot2::geom_point()

```

## TODO

[There is evidence](https://twitter.com/Torvaney/status/1623316194936725506) that the current score of a match effects shooting rate, but it's not so clear that it has [an effect on conversion probability](https://kwiatkowski.io/rethinking-shots).

## Conclustion

So, we've shown that model calibration improves the accuracy of xPts. We achieved this by tuning xG with game state. Depending on the context, if one finds that a variable improves model performance when accounted for in a post-training calibration step. one might consider adding said variable as an additional feature for training. However, if one only has access to a model's output, as we did here with xG, then calibration can be a really sound choice.

While I would not suggest that xG models should be modified to take game state as an additional feature since it would compromise the conceptual integrity of such a model, one might choose

*"Why should accounting for game state create a more accurate set of xPts? Doesn't xG already directly capture the fact that teams trailing in a match may be taking more, lower quality shots?"* Well, there are at least two confounding factors that immediately come to mind:

1.  Players on the trailing team may be taking more off-balance or rushed shots that they would not otherwise take. Traditional xG model, which do not account for body pose or footedness, do not capture this kind of "desperateness".
2.  Players on teams that fall behind their opponents tend to have less finishing skill. Lower finishing skill generally manifests in worse goal conversion rates. Thust, the xG of shots taken by such players may tend to overrate their actual number of goals scored.

A picture is worth a thousand words.
