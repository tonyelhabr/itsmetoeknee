---
title: Meta-Analytics for Soccer 
description: Calculating discrimination and stability (Franks et al. 2017) for soccer stats
date: 2023-09-10
draft: true
categories:
  - r
  - soccer
image: foo.png
execute: 
  code-fold: true
  eval: false
  include: true
  echo: true
---

## Introduction

In the realm of sports, data analysis has grown significantly, introducing numerous metrics to guide coaching, management, and, of course, fans. However, this proliferation has also led to confusion, with overlapping and sometimes conflicting metrics. To address this, the [Franks et al. (2017)](https://www.degruyter.com/document/doi/10.1515/jqas-2016-0098/html)[^1] propose three "meta-metrics" to help determine which metrics offer unique and dependable information for decision-makers.

[^1]: If it means anything, the *Meta-analytics* paper has [40 citations](https://scholar.google.com/scholar?cites=13818794209592074425&as_sdt=5,44&sciodt=0,44&hl=en) at time of writing, suggesting it has had non-trivial influence on subsequent sports analytics research.

By examining sources of variation in sports metrics (e.g. intrinsic player skill), Franks et al. introduce three key meta-metrics to assess player performance metrics:

-   **discrimination**: How good is the metric at telling players apart?
-   **stability**: How likely is that a player maintains the same performance for the metric in the next season?
-   **independence**: Does the stat tell us something different about players that other stats don't tell us?

This blog post demonstrates how to calculate the **discrimination** and **stability** meta-metrics on an array of soccer stats.

### Definitions

Before we dive into implementation, we should more specifically define the meta-metrics of interest, discrimination and stability. I'll break things down more formally first, but if you want just the gist of things, at least observe the "Simplified" formulas.

#### Full Formulas

Let $X$ to be a random variable. Given metric $m$ for player $p$ from season $s$, we can represent a single value of the random variable as $X_{spm}$. Given these representations, we specify the following shorthands.

$$
\begin{array}{rcl}
E_{spm}[X] & = & E[X|S=s,P=p,M=m] \\
V_{spm}[X] & = & Var[X|S=s,P=p,M=m]. \\
\end{array}
$$

Franks et al. define discrimination as

$$
\begin{array}{cc}
\text{(Discrimination)} & D_{sm} = 1 - \frac{E_{sm}[V_{spm}[X]]}{V_{sm}[X]}.
\end{array}
$$ {#eq-discrimination-full}

This describes **the fraction of between-player variance due to true differences in player ability**. A value closer to 1 indicates a metric that can differentiate between players more precisely.[^2]

[^2]: Note that we can average $D_{sm}$ across all seasons of interest to arrive at a singular value per metric, $D_m$.

Stability is defined as

$$
\begin{array}{cc}
\text{(Stability)} & S_{m} = 1 - \frac{E_{m}[V_{spm}[X] - V_{spm}[X]]}{V_{m}[X] - E_{m}[V_{spm}[X]]}.
\end{array}
$$ {#eq-stability-full}

This represents **the fraction of total variance that is due to within-player changes over time**. A value closer to 1 indicates that the value for a stat for a given player is less likely to change from season to season.

#### Simplified Formulas

Let's abstract one level up from metric $m$, since, fundamentally, it should be intuitive that we won't be looking at variance across different stats, i.e. variance across shots taken and passes completed doesn't make sense. Further, removing the notation for seasons, players, expectations, and variances for clarity, we can re-write @eq-discrimination-full more plainly as

$$
\text{(Discrimination)} = 1 - \frac{BV}{SV}.
$$ {#eq-discrimination-short}

$BV$ is the **b**ootstrapped **v**ariability (of a given metric) for a given player in a given season (1 record per "player-season"), averaged over all player-seasons. $SV$ is the player-season **v**ariance for all players for a given **s**eason.

Next, we can re-write @eq-stability-full as

$$
\text{(Stability)} = 1 - \frac{WV - BV}{TV - BV}.
$$ {#eq-stability-short}

$WV$ represents the **v**ariance across all player-seasons **w**ithin a player. $TV$ is the **t**otal **v**ariance across all player-season totals over all seasons.

## Inference

### Data

We'll be using public data from [FBref](https://fbref.com/) for the 2018/19 - 2022/23 seasons of the [the Big 5 European soccer leagues](https://fbref.com/en/comps/Big5/Big-5-European-Leagues-Stats).

```{r}
#| label: data-pull
#| code-fold: true
#| code-summary: Data retrieval
library(dplyr)
library(tidyr)
library(purrr)
library(tibble)
library(lubridate)

load_fb_advanced_match_stats <- function(country, gender, tier, stat_type, team_or_player, season_end_year = NA) {
  
  url <- sprintf(
    'https://github.com/JaseZiv/worldfootballR_data/releases/download/fb_advanced_match_stats/%s_%s_%s_%s_%s_advanced_match_stats.rds',
    country,
    gender,
    tier,
    stat_type,
    team_or_player
  )
  readRDS(url(url))
}

possibly_load_fb_advanced_match_stats <- purrr::possibly(
  load_fb_advanced_match_stats, 
  otherwise = tibble::tibble(),
  quiet = TRUE
)

params <- tidyr::expand_grid(
  country = c('ENG', 'ESP', 'FRA', 'GER', 'ITA'),
  gender = 'M',
  tier = '1st',
  stat_type = 'summary',
  team_or_player = 'player'
) |> 
  as.list()

raw_player_match_stats <- purrr::pmap_dfr(
  params,
  possibly_load_fb_advanced_match_stats
) |> 
  dplyr::filter(
    ## stop at 2022/23 season
    Season_End_Year < 2024L,
    ## don't include keepers
    !grepl('GK', Pos)
  )

BASE_METRICS <- c(
  'goals',
  'assists',
  'shots',
  'shots_on_target',
  'touches',
  'tackles',
  'interceptions',
  'blocks',
  'xg',
  'npxg',
  'xa',
  'sca',
  'gca',
  'passes_completed',
  'passes_attempted',
  'progressive_passes',
  'carries',
  'progressive_carries',
  'takeons_attempted',
  'successful_takeons'
)

RATE_METRICS <- c(
  'goal_conversion_rate',
  'pass_completion_rate',
  'successful_takeon_rate'
)

ALL_METRICS <- c(
  BASE_METRICS,
  RATE_METRICS
)

player_match_stats <- raw_player_match_stats |> 
  dplyr::transmute(
    league = sprintf('%s-%s-%s', Country, Gender, Tier),
    season = sprintf('%s/%s', Season_End_Year - 1, substr(Season_End_Year, 3, 4)),
    date = lubridate::ymd(Match_Date),
    match_id = basename(dirname(MatchURL)),
    team = Team,
    player = Player,
    minutes_played = Min,
    
    goals = Gls, ## includes pks
    assists = Ast,
    shots = Sh, ## does not include pk attempts
    shots_on_target = SoT,
    touches = Touches,
    tackles = Tkl,
    interceptions = Int,
    blocks = Blocks,
    
    xg = xG_Expected,
    npxg = npxG_Expected,
    xa = xAG_Expected,
    
    sca = SCA_SCA,
    gca = GCA_SCA,
    
    passes_completed = Cmp_Passes,
    passes_attempted = Att_Passes,
    
    progressive_passes = PrgP_Passes,
    carries = Carries_Carries,
    progressive_carries = PrgC_Carries,
    
    takeons_attempted = Att_Take_Ons,
    successful_takeons = Succ_Take_Ons
  )

coalesce_fraction <- purrr::compose(
  \(num, den) ifelse(num > 0 & den == 0, 0, num / den),
  \(x) dplyr::coalesce(x, 0),
  \(x) ifelse(x > 1, 1, x),
  \(x) ifelse(x < 0, 0, x),
  .dir = 'forward'
)

summarize_all_metric_columns <- function(df, ...) {
  df |> 
    dplyr::group_by(..., league, season, team, player) |> 
    dplyr::summarize(
      dplyr::across(
        c(minutes_played, dplyr::all_of(BASE_METRICS)), 
        sum
      )
    ) |> 
    dplyr::ungroup() |> 
    dplyr::mutate(
      ## Mark Noble with the epic 1 goal on 0 shots https://fbref.com/en/matches/b56fd899/Watford-West-Ham-United-December-28-2021-Premier-League
      goal_conversion_rate = coalesce_fraction(goals, shots),
      pass_completion_rate = coalesce_fraction(passes_completed, passes_attempted),
      successful_takeon_rate = coalesce_fraction(successful_takeons, takeons_attempted)
    )
}

player_team_season_mapping <- player_match_stats |> 
  dplyr::group_by(league, season, team, player) |>
  dplyr::filter(minutes_played > 0L) |> 
  dplyr::summarize(
    dplyr::across(minutes_played, sum),
    matches_played = dplyr::n_distinct(match_id)
  ) |> 
  dplyr::ungroup()

player_season_stats <- summarize_all_metric_columns(player_match_stats)

## Franks et al. used 250 min played for the NBA
## https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L60
MIN_MINUTES_PLAYED <- 270
eligible_player_season_stats <- player_season_stats |> 
  dplyr::filter(minutes_played >= MIN_MINUTES_PLAYED)

eligible_player_match_stats <- player_match_stats |> 
  dplyr::semi_join(
    eligible_player_season_stats,
    by = dplyr::join_by(league, season, team, player)
  ) |> 
  dplyr::arrange(league, season, team, player)
```

```{r}
#| label: data-pull-save
#| include: false
# library(qs)
PROJ_DIR <- 'posts/soccer-meta-analytics'
qs::qsave(eligible_player_season_stats, file.path(PROJ_DIR, 'eligible_player_season_stats.qs'))
qs::qsave(eligible_player_match_stats, file.path(PROJ_DIR, 'eligible_player_match_stats.qs'))
```

After some light wrangling, the data we'll be working with looks like this.

```{r}
#| label: glimpse-data-pull
#| code-fold: false
dplyr::glimpse(eligible_player_match_stats)
#> Rows: 271,416
#> Columns: 27
#> $ league              <chr> "ENG-M-1st", "ENG-M-1st", "ENG-M-1st", "ENG-M-1…
#> $ season              <chr> "2018/19", "2018/19", "2018/19", "2018/19", "20…
#> $ date                <date> 2018-08-12, 2018-08-18, 2018-08-25, 2018-09-02…
#> $ match_id            <chr> "478e9dab", "9b69882c", "0014076a", "c1503e09",…
#> $ team                <chr> "Arsenal", "Arsenal", "Arsenal", "Arsenal", "Ar…
#> $ player              <chr> "Aaron Ramsey", "Aaron Ramsey", "Aaron Ramsey",…
#> $ minutes_played      <dbl> 53, 23, 90, 90, 79, 79, 62, 24, 11, 13, 18, 16,…
#> $ goals               <dbl> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…
#> $ assists             <dbl> 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 2, 0, 0,…
#> $ shots               <dbl> 1, 2, 2, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 3, 1, 0,…
#> $ shots_on_target     <dbl> 1, 1, 1, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,…
#> $ touches             <dbl> 18, 11, 67, 78, 63, 34, 24, 26, 17, 10, 12, 12,…
#> $ tackles             <dbl> 2, 0, 2, 1, 2, 0, 2, 0, 1, 0, 0, 0, 1, 2, 1, 0,…
#> $ interceptions       <dbl> 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,…
#> $ blocks              <dbl> 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0,…
#> $ xg                  <dbl> 0.0, 0.1, 0.1, 0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.…
#> $ npxg                <dbl> 0.0, 0.1, 0.1, 0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.…
#> $ xa                  <dbl> 0.1, 0.0, 0.2, 0.2, 0.1, 0.4, 0.0, 0.1, 0.0, 0.…
#> $ sca                 <dbl> 1, 1, 5, 7, 4, 3, 0, 1, 0, 0, 0, 1, 1, 3, 1, 0,…
#> $ gca                 <dbl> 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0, 1, 0, 2, 0, 0,…
#> $ passes_completed    <dbl> 9, 6, 48, 51, 49, 26, 16, 16, 13, 5, 11, 7, 8, …
#> $ passes_attempted    <dbl> 13, 9, 61, 66, 58, 31, 20, 21, 15, 7, 12, 10, 8…
#> $ progressive_passes  <dbl> 1, 1, 9, 6, 5, 4, 2, 2, 1, 0, 1, 1, 0, 3, 4, 3,…
#> $ carries             <dbl> 5, 7, 41, 49, 43, 27, 21, 16, 11, 8, 11, 7, 7, …
#> $ progressive_carries <dbl> 1, 0, 5, 2, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 4, 2,…
#> $ takeons_attempted   <dbl> 1, 0, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 2,…
#> $ successful_takeons  <dbl> 1, 0, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,…
```

Easy enough. Now we can dive right in and calculate the meta-metrics of interest.

### Discrimination

We'll beging with the discrimination meta-metric, which means we'll need to calculate "bootstrap variance", $BV$, and, "seasonal variance", $SV$, as shown in @eq-discrimination-short. Starting with the former, we need to first resample player matches within teams, with replacement.

```{r}
#| label: resampled_player_match_stats
#| code-fold: true
#| code-summary: Bootstrap empirical player-seasons
resample_stats <- function(player_match_stats) {
  
  match_ids <- player_match_stats |>
    dplyr::distinct(league, season, team, date, match_id) |> 
    dplyr::arrange(league, season, team, date)
  
  ## can't just specify to resample 38 matches per team since different leagues 
  ## have different season lengths (Bundesliga)
  resampled_match_ids <- match_ids |> 
    dplyr::select(league, season, team, match_id) |> 
    dplyr::group_by(league, season, team) |> 
    dplyr::summarize(
      match_id = list(match_id)
    ) |> 
    dplyr::ungroup() |> 
    dplyr::mutate(
      match_id = purrr::map(
        match_id,
        \(.x) {
          sample(.x, size = length(.x), replace = TRUE)
        })
    ) |> 
    tidyr::unnest(match_id)
  
  resampled_match_ids |> 
    dplyr::inner_join(
      player_match_stats,
      by = dplyr::join_by(league, season, team, match_id),
      relationship = 'many-to-many'
    )
}

## Franks et al. used 20 bootstrap replicates
## https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L70
N_BOOSTRAPS <- 20
set.seed(42)
resampled_player_match_stats <- purrr::map_dfr(
  rlang::set_names(1:N_BOOSTRAPS),
  \(...) {
    resample_stats(
      player_match_stats = eligible_player_match_stats
    )
  },
  .id = 'bootstrap_id'
) |> 
  dplyr::mutate(bootstrap_id = as.integer(bootstrap_id))
```

And, then, after we aggregate over the bootstraps to create single player-season summaries, we get a data frame that looks like this

```{r}
#| label: resampled_player_season_stats
#| code-fold: true
#| code-summary: Aggregate bootstraps
resampled_player_match_stats <- resampled_player_match_stats |> 
  ## Franks et al. did this
  ## https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L78
  dplyr::filter(minutes_played < (0.75 * MIN_MINUTES_PLAYED))

resampled_player_season_stats <- resampled_player_match_stats |> 
  summarize_all_metric_columns(bootstrap_id) |> 
  dplyr::arrange(bootstrap_id, league, season, team, player)
```

```{r}
#| label: save-resampled_player_season_stats
#| include: false
qs::qsave(resampled_player_season_stats, file.path(PROJ_DIR, 'resampled_player_season_stats.qs'))
```

```{r}
#| label: glimpse-resampled_player_season_stats
#| code-fold: false
dplyr::glimpse(resampled_player_season_stats)
#> Rows: 234,172
#> Columns: 29
#> $ bootstrap_id           <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…
#> $ league                 <chr> "ENG-M-1st", "ENG-M-1st", "ENG-M-1st", "ENG-…
#> $ season                 <chr> "2018/19", "2018/19", "2018/19", "2018/19", …
#> $ team                   <chr> "Arsenal", "Arsenal", "Arsenal", "Arsenal", …
#> $ player                 <chr> "Aaron Ramsey", "Ainsley Maitland-Niles", "A…
#> $ minutes_played         <dbl> 1349, 1053, 1714, 2767, 2213, 1357, 989, 138…
#> $ goals                  <dbl> 2, 2, 3, 11, 4, 3, 0, 5, 0, 0, 7, 0, 2, 20, …
#> $ assists                <dbl> 1, 1, 4, 8, 2, 5, 3, 0, 3, 0, 2, 0, 4, 4, 0,…
#> $ shots                  <dbl> 28, 8, 31, 102, 24, 30, 7, 5, 21, 20, 14, 9,…
#> $ shots_on_target        <dbl> 9, 6, 15, 28, 11, 11, 4, 5, 1, 4, 9, 0, 6, 2…
#> $ touches                <dbl> 1058, 706, 1096, 1335, 2279, 927, 680, 1052,…
#> $ tackles                <dbl> 37, 28, 21, 35, 44, 17, 9, 21, 61, 35, 9, 21…
#> $ interceptions          <dbl> 10, 17, 14, 19, 34, 9, 13, 36, 55, 23, 3, 0,…
#> $ blocks                 <dbl> 4, 33, 21, 26, 23, 25, 6, 20, 41, 29, 9, 9, …
#> $ xg                     <dbl> 2.7, 1.6, 4.2, 11.0, 1.0, 3.9, 0.3, 1.9, 0.6…
#> $ npxg                   <dbl> 2.7, 1.6, 4.2, 11.0, 1.0, 3.9, 0.3, 1.9, 0.6…
#> $ xa                     <dbl> 2.4, 0.9, 5.3, 3.6, 2.0, 4.8, 0.9, 0.5, 0.7,…
#> $ sca                    <dbl> 54, 21, 68, 99, 63, 66, 20, 9, 41, 60, 94, 2…
#> $ gca                    <dbl> 6, 2, 8, 14, 4, 15, 5, 0, 12, 2, 10, 0, 10, …
#> $ passes_completed       <dbl> 733, 444, 619, 677, 1656, 552, 470, 832, 126…
#> $ passes_attempted       <dbl> 906, 561, 847, 933, 2059, 724, 580, 905, 150…
#> $ progressive_passes     <dbl> 97, 59, 120, 120, 221, 83, 46, 37, 137, 223,…
#> $ carries                <dbl> 630, 334, 724, 738, 1085, 454, 333, 602, 978…
#> $ progressive_carries    <dbl> 51, 31, 116, 61, 32, 53, 28, 13, 32, 91, 80,…
#> $ takeons_attempted      <dbl> 21, 31, 80, 96, 12, 45, 9, 2, 27, 33, 35, 4,…
#> $ successful_takeons     <dbl> 15, 20, 43, 63, 6, 11, 8, 2, 12, 25, 25, 2, …
#> $ goal_conversion_rate   <dbl> 0.07142857, 0.25000000, 0.09677419, 0.107843…
#> $ pass_completion_rate   <dbl> 0.8090508, 0.7914439, 0.7308146, 0.7256163, …
#> $ successful_takeon_rate <dbl> 0.7142857, 0.6451613, 0.5375000, 0.6562500, …
```

Next, we calculate the bootstrap variance across the player-season bootstraps. Then we take the average of the bootstrap variance over all player-seasons, grouping by season, to arrive at $BV$. (1 value per season and metric.)

```{r}
#| label: bv
#| code-fold: true
#| code-summary: Calculate bootstrap variance, BV
pivot_metric_columns <- function(df) {
  df |> 
    dplyr::select(
      league,
      season,
      team,
      player,
      dplyr::all_of(ALL_METRICS)
    ) |> 
    tidyr::pivot_longer(
      -c(league, season, team, player),
      names_to = 'metric',
      values_to = 'value'
    )
}

resampled_player_season_variance <- resampled_player_season_stats |> 
  pivot_metric_columns() |> 
  dplyr::group_by(season, team, player, metric) |> 
  dplyr::summarize(
    bv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup()

bv <- resampled_player_season_variance |> 
  dplyr::group_by(season, metric) |> 
  dplyr::summarize(
    bv = mean(bv, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: save-bv
#| include: false
qs::qsave(bv, file.path(PROJ_DIR, 'bv.qs'))
```

```{r}
#| label: glimpse-bv
#| code-fold: false
bv
#> # A tibble: 138 × 3
#>    season  metric                         bv
#>    <chr>   <chr>                       <dbl>
#>  1 2017/18 assists                  1.64    
#>  2 2017/18 blocks                  26.3     
#>  3 2017/18 carries               7712.      
#>  4 2017/18 gca                      4.65    
#>  5 2017/18 goal_conversion_rate     0.00625 
#>  6 2017/18 goals                    2.36    
#>  7 2017/18 interceptions           33.4     
#>  8 2017/18 npxg                     0.761   
#>  9 2017/18 pass_completion_rate     0.000639
#> 10 2017/18 passes_attempted     15725.      
#> # ℹ 128 more rows
```

Next, we move on to the "seasonal variance", $SV$. This is actually pretty trivial, as it's just a direct call to `stats::var` on the empirical player-season aggregates, grouping by season. We end up with 1 row per season and metric, as we do with $BV$.

```{r}
#| label: sv
#| code-fold: true
#| code-summary: Calculate seasonal variance, SV
pivoted_player_season_stats <- pivot_metric_columns(player_season_stats)

sv <- pivoted_player_season_stats |>
  dplyr::group_by(season, metric) |> 
  dplyr::summarize(
    sv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: save-sv
#| include: false
qs::qsave(sv, file.path(PROJ_DIR, 'sv.qs'))
```

```{r}
#| label: glimpse-sv
#| code-fold: false
sv
#> # A tibble: 138 × 3
#>    season  metric                        sv
#>    <chr>   <chr>                      <dbl>
#>  1 2017/18 assists                   4.33  
#>  2 2017/18 blocks                  186.    
#>  3 2017/18 carries              153542.    
#>  4 2017/18 gca                      19.3   
#>  5 2017/18 goal_conversion_rate      0.0120
#>  6 2017/18 goals                    12.4   
#>  7 2017/18 interceptions           319.    
#>  8 2017/18 npxg                      7.27  
#>  9 2017/18 pass_completion_rate      0.0112
#> 10 2017/18 passes_attempted     337383.    
#> # ℹ 128 more rows
```

Now, the easy part---bringing $BV$ and $SV$ together to calculate discrimination, by season.

```{r}
#| label: discrimination
#| code-fold: show
#| code-summary: Calculate discrimination
discrimination <- bv |> 
  dplyr::inner_join(
    sv,
    by = dplyr::join_by(season, metric)
  ) |> 
  dplyr::mutate(
    discrimination = 1 - bv / sv
  ) |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: save-discrimination
#| include: false
qs::qsave(discrimination, file.path(PROJ_DIR, 'discrimination.qs'))
```

```{r}
#| label: glimpse-discrimination
#| code-fold: false
discrimination
#> # A tibble: 138 × 5
#>    season  metric                         bv          sv discrimination
#>    <chr>   <chr>                       <dbl>       <dbl>          <dbl>
#>  1 2017/18 assists                  1.64          4.33            0.621
#>  2 2017/18 blocks                  26.3         186.              0.859
#>  3 2017/18 carries               7712.       153542.              0.950
#>  4 2017/18 gca                      4.65         19.3             0.759
#>  5 2017/18 goal_conversion_rate     0.00625       0.0120          0.481
#>  6 2017/18 goals                    2.36         12.4             0.810
#>  7 2017/18 interceptions           33.4         319.              0.895
#>  8 2017/18 npxg                     0.761         7.27            0.895
#>  9 2017/18 pass_completion_rate     0.000639      0.0112          0.943
#> 10 2017/18 passes_attempted     15725.       337383.              0.953
#> # ℹ 128 more rows
```

### Stability

For stability, in addition to $BV$ and $SV$, we need to calculate "within player" variance, $WV$, and the "total variance", $TV$.[^3]

[^3]: Note that these are convenient short names as, in reality, $WV$ is the within player variance prior to subtracting out the relevant sampling variance, $BV$, and $TV$ is the total variance prior to subtracting out the same sampling variance, $BV$.

We start with $WV$. Like $SV$, the calculation is actually fairly straightforward. We group on the appropriate columns, calculate variance with `stats::var()`, group again on a subset of the prior columns, then calculate the average variance with `stats::mean()`.

```{r}
#| label: wv
#| code-fold: true
#| code-summary: Calculate within player variance, WV
within_player_variance <- pivoted_player_season_stats |> 
  ## should check for players with the same name
  dplyr::group_by(league, team, player, metric) |>
  dplyr::summarize(
    seasons_played = dplyr::n(),
    wv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup()

wv <- within_player_variance |>
  ## Franks et al. don't have something quite like this, where they filter for
  ##   a minimum number of seasons played. I think they didn't find it necessary
  ##   after dropping player who have ever had zeros, and because they were working
  ##   with 20 seasons of NBA data. (I'm working with 6.)
  dplyr::filter(
    seasons_played >= 3L
  ) |> 
  dplyr::group_by(metric) |> 
  dplyr::summarize(
    wv = mean(wv, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(metric)
```

```{r}
#| label: save-wv
#| include: false
qs::qsave(wv, file.path(PROJ_DIR, 'wv.qs'))
```

```{r}
#| label: glimpse-wv
#| code-fold: false
wv
#> # A tibble: 23 × 2
#>    metric                         wv
#>    <chr>                       <dbl>
#>  1 assists                   2.71   
#>  2 blocks                   96.2    
#>  3 carries               77143.     
#>  4 gca                      10.0    
#>  5 goal_conversion_rate      0.00954
#>  6 goals                     5.75   
#>  7 interceptions           122.     
#>  8 npxg                      2.85   
#>  9 pass_completion_rate      0.00721
#> 10 passes_attempted     153729.     
#> # ℹ 13 more rows
```

Note that there is just one record per metric.[^4]

[^4]: This agrees with the notation indicated in @eq-stability-full, where there is just one subscript, for metric $m$. Compare this to the two subscripts for both season $s$ and metric $m$ in @eq-discrimination-full. Accordingly, our `discrimination` variable has one row per season and metric.

Finally, we calculate "total variance", $TV$. This is the most straightforward of all our variance calculations, as it involves just a call to `stats::var()` for each metric on the empirical player-season stats.

```{r}
#| label: tv
#| code-fold: true
#| code-summary: Calculate total variance, TV
tv <- pivoted_player_season_stats |> 
  dplyr::group_by(metric) |>
  dplyr::summarize(
    tv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(metric)
```

```{r}
#| label: save-tv
#| include: false
qs::qsave(tv, file.path(PROJ_DIR, 'tv.qs'))
```

```{r}
#| label: glimpse-tv
#| code-fold: false
tv
#> # A tibble: 23 × 2
#>    metric                        tv
#>    <chr>                      <dbl>
#>  1 assists                   4.16  
#>  2 blocks                  177.    
#>  3 carries              161078.    
#>  4 gca                      17.9   
#>  5 goal_conversion_rate      0.0128
#>  6 goals                    11.5   
#>  7 interceptions           252.    
#>  8 npxg                      6.86  
#>  9 pass_completion_rate      0.0179
#> 10 passes_attempted     339330.    
#> # ℹ 13 more rows
```

Finally, we bring $BV$, $WV$ and $TV$ together to calculate stability.

```{r}
#| label: stability
#| code-fold: true
#| code-summary: Calculate stability
stability <- bv |> 
  dplyr::group_by(metric) |> 
  dplyr::summarize(
    bv = mean(bv)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::inner_join(
    tv,
    by = dplyr::join_by(metric)
  ) |>
  dplyr::inner_join(
    wv,
    by = dplyr::join_by(metric)
  ) |> 
  dplyr::mutate(
    stability = 1 - (wv - bv) / (tv - bv)
  ) |> 
  dplyr::arrange(metric)
```

```{r}
#| label: save-stability
#| include: false
qs::qsave(stability, file.path(PROJ_DIR, 'stability.qs'))
```

```{r}
#| label: glimpse-stability
#| code-fold: false
stability
#> # A tibble: 23 × 5
#>    metric                        bv          tv           wv stability
#>    <chr>                      <dbl>       <dbl>        <dbl>     <dbl>
#>  1 assists                  1.66         4.16        2.71        0.580
#>  2 blocks                  25.8        177.         96.2         0.533
#>  3 carries               7808.      161078.      77143.          0.548
#>  4 gca                      4.64        17.9        10.0         0.592
#>  5 goal_conversion_rate     0.00707      0.0128      0.00954     0.569
#>  6 goals                    2.38        11.5         5.75        0.629
#>  7 interceptions           27.8        252.        122.          0.577
#>  8 npxg                     0.746        6.86        2.85        0.656
#>  9 pass_completion_rate     0.00108      0.0179      0.00721     0.635
#> 10 passes_attempted     14995.      339330.     153729.          0.572
#> # ℹ 13 more rows
```

## Results

## Conclusion

> discrimination, which is a meta-metric that describes variation within a single season, it is important to understand how much an individual player's metric varies from season to season.

> Our discrimination meta-metric quantifies how useful a metric is for distinguishing between players within a given season, whereas our stability meta-metric measures how much a metric varies season to season due to changes in context and player skill after removing chance variation

[Repository](https://github.com/afranks86/meta-analytics)
