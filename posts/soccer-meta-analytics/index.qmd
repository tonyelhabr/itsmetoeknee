---
title: Meta-Analytics for Soccer 
description: Calculating discrimination and stability (Franks et al. 2017) for soccer stats
date: 2023-09-10
draft: true
categories:
  - r
  - soccer
image: foo.png
execute: 
  code-fold: true
  eval: false
  include: true
  echo: true
---

## Introduction

In the realm of sports, data analysis has grown significantly, introducing numerous metrics to guide coaching, management, and, of course, fans. However, this proliferation has also led to confusion, with overlapping and sometimes conflicting metrics. To address this, the [Franks et al. (2017)](https://www.degruyter.com/document/doi/10.1515/jqas-2016-0098/html)[^1] propose three "meta-metrics" to help determine which metrics offer unique and dependable information for decision-makers.

[^1]: If it means anything, the *Meta-analytics* paper has [40 citations](https://scholar.google.com/scholar?cites=13818794209592074425&as_sdt=5,44&sciodt=0,44&hl=en) at time of writing, suggesting it has had non-trivial influence on subsequent sports analytics research.

By examining sources of variation in sports metrics (e.g. intrinsic player skill), Franks et al. introduce three key meta-metrics to assess player performance metrics:

-   **discrimination**: How good is the metric at telling players apart?
-   **stability**: How likely is that a player maintains the same performance for the metric in the next season?
-   **independence**: Does the stat tell us something different about players that other stats don't tell us?

This blog post demonstrates how to calculate the **discrimination** and **stability** meta-metrics on an array of soccer stats.

### Definitions

Before we dive into implementation, we should more specifically define the meta-metrics of interest, discrimination and stability. I'll break things down more formally first, but if you want just the gist of things, at least observe the "Simplified" formulas.

#### Full Formulas

Let $X$ to be a random variable. Given metric $m$ for player $p$ from season $s$, we can represent a single value of the random variable as $X_{spm}$. Given these representations, we specify the following shorthands.

$$
\begin{array}{rcl}
E_{spm}[X] & = & E[X|S=s,P=p,M=m] \\
V_{spm}[X] & = & Var[X|S=s,P=p,M=m]. \\
\end{array}
$$

Franks et al. define discrimination as

$$
\begin{array}{cc}
\text{(Discrimination)} & D_{sm} = 1 - \frac{E_{sm}[V_{spm}[X]]}{V_{sm}[X]}.
\end{array}
$$ {#eq-discrimination-full}

This describes **the fraction of between-player variance due to true differences in player ability**. A value closer to 1 indicates a metric that can differentiate between players more precisely.[^2]

[^2]: Note that we can average $D_{sm}$ across all seasons of interest to arrive at a singular value per metric, $D_m$.

Stability is defined as

$$
\begin{array}{cc}
\text{(Stability)} & S_{m} = 1 - \frac{E_{m}[V_{spm}[X] - V_{spm}[X]]}{V_{m}[X] - E_{m}[V_{spm}[X]]}.
\end{array}
$$ {#eq-stability-full}

This represents **the fraction of total variance that is due to within-player changes over time**. A value closer to 1 indicates that the value for a stat for a given player is less likely to change from season to season.

#### Simplified Formulas

Let's abstract one level up from metric $m$, since, fundamentally, it should be intuitive that we won't be looking at variance across different stats, i.e. variance across shots taken and passes completed doesn't make sense. Further, we'll remove the subscripts and other notation for seasons, players, expectations, and variances for clarity.

We re-write @eq-discrimination-full more plainly as

$$
\begin{array}{cc}
\text{(Discrimination)} & 1 - \frac{BV}{SV}.
\end{array}
$$ {#eq-discrimination-short}

$BV$ is the **b**ootstrapped **v**ariance for a given player in a given season (1 record per "player-season"), averaged over all player-seasons. $SV$ is the player-season **v**ariance for all players for a given **s**eason.

Next, let's re-write @eq-stability-full as

$$
\begin{array}{cc}
\text{(Stability)} & 1 - \frac{WV - BV}{TV - BV}.
\end{array}
$$ {#eq-stability-short}

$WV$ represents the **v**ariance across all player-seasons **w**ithin a player. $TV$ is the **t**otal **v**ariance across all player-season totals over all seasons.

## Inference

### Data

We'll be using public data from [FBref](https://fbref.com/) for the 2018/19 - 2022/23 seasons of the [the Big 5 European soccer leagues](https://fbref.com/en/comps/Big5/Big-5-European-Leagues-Stats).

```{r}
#| label: data-pull
#| code-fold: true
#| code-summary: Retrieve and wrangle data
library(dplyr)
library(tidyr)
library(purrr)
library(tibble)

load_fb_advanced_match_stats <- function(country, gender, tier, stat_type, team_or_player, season_end_year = NA) {
  
  url <- sprintf(
    'https://github.com/JaseZiv/worldfootballR_data/releases/download/fb_advanced_match_stats/%s_%s_%s_%s_%s_advanced_match_stats.rds',
    country,
    gender,
    tier,
    stat_type,
    team_or_player
  )
  readRDS(url(url))
}

possibly_load_fb_advanced_match_stats <- purrr::possibly(
  load_fb_advanced_match_stats, 
  otherwise = tibble::tibble(),
  quiet = TRUE
)

params <- tidyr::expand_grid(
  country = c('ENG', 'ESP', 'FRA', 'GER', 'ITA'),
  gender = 'M',
  tier = '1st',
  stat_type = 'summary',
  team_or_player = 'player'
) |> 
  as.list()

raw_player_match_stats <- purrr::pmap_dfr(
  params,
  possibly_load_fb_advanced_match_stats
) |> 
  dplyr::filter(
    ## stop at 2022/23 season
    Season_End_Year < 2024L,
    ## don't include keepers
    !grepl('GK', Pos)
  )

BASE_METRICS <- c(
  'goals',
  'assists',
  'shots',
  'shots_on_target',
  'touches',
  'tackles',
  'interceptions',
  'blocks',
  'xg',
  'npxg',
  'xa',
  'sca',
  'gca',
  'passes_completed',
  'passes_attempted',
  'progressive_passes',
  'carries',
  'progressive_carries',
  'takeons_attempted',
  'successful_takeons'
)

RATE_METRICS <- c(
  'shot_conversion_rate',
  'pass_completion_rate',
  'successful_takeon_rate'
)

# ALL_METRICS <- c(
#   setdiff(
#     BASE_METRICS,
#     c(
#       'blocks',
#       'sca',
#       'gca',
#       'carries',
#       'passes_attempted',
#       'takeons_attempted'
#     )
#   ),
#   RATE_METRICS
# )

ALL_METRICS <- c(
  'goals' = 'Goals',
  'assists' = 'Assists',
  'shots' = 'Shots',
  'shots_on_target' = 'Shots on Target',
  # 'touches' = 'Touches',
  'tackles' = 'Tackles',
  'interceptions' = 'Interceptions',
  'xg' = 'xG',
  # 'npxg' = 'npxG',
  'xa' = 'xA',
  'passes_completed' = 'Passes Completed',
  'carries' = 'Carries',
  # 'progressive_passes' = 'Progressive Passes',
  # 'progressive_carries' = 'Progressive Carries',
  # 'successful_takeons' = 'Successful Take-ons',
  'shot_conversion_rate' = 'Shots Conversion Rate',
  'pass_completion_rate' = 'Pass Completion Rate',
  # 'successful_takeon_rate' = 'Successful Take-on %',
  'xg_p90' = 'xG/90',
  # 'npxg_p90' = 'npxG/90',
  'goals_p90' = 'Goals/90',
  'goals_xg_ratio' = 'Goals/xG'
)

player_match_stats <- raw_player_match_stats |> 
  dplyr::transmute(
    league = sprintf('%s-%s-%s', Country, Gender, Tier),
    season = sprintf('%s/%s', Season_End_Year - 1, substr(Season_End_Year, 3, 4)),
    date = Match_Date,
    match_id = basename(dirname(MatchURL)),
    team = Team,
    player = Player,
    nation = Nation, ## to help uniquely identify players

    minutes_played = Min,
    
    goals = Gls, ## includes pks
    assists = Ast,
    shots = Sh, ## does not include pk attempts
    shots_on_target = SoT,
    # touches = Touches,
    tackles = Tkl,
    interceptions = Int,
    blocks = Blocks,
    
    xg = xG_Expected,
    # npxg = npxG_Expected,
    xa = xAG_Expected,
    
    # sca = SCA_SCA,
    # gca = GCA_SCA,

    # takeons_attempted = Att_Take_Ons,
    # successful_takeons = Succ_Take_Ons,
        
    # progressive_passes = PrgP_Passes,
    # progressive_carries = PrgC_Carries,
    
    passes_completed = Cmp_Passes,
    passes_attempted = Att_Passes,
    carries = Carries_Carries
  )

safe_divide <- function(num, den) {
  case_when(
    den == 0 | is.na(den) ~ NA_real_,
    TRUE ~ dplyr::coalesce(num / den, 0)
  )
}

coalesce_fraction <- purrr::compose(
  \(num, den) safe_divide(num, den),
  \(x) ifelse(x > 1, 1, x),
  \(x) ifelse(x < 0, 0, x),
  .dir = 'forward'
)

summarize_all_metric_columns <- function(df, ...) {
  df |> 
    dplyr::group_by(..., league, season, team, player, nation) |> 
    dplyr::summarize(
      dplyr::across(
        c(minutes_played:dplyr::last_col()),
        sum
      )
    ) |> 
    dplyr::ungroup() |> 
    dplyr::mutate(
      ## Mark Noble with the epic 1 goal on 0 shots https://fbref.com/en/matches/b56fd899/Watford-West-Ham-United-December-28-2021-Premier-League
      shot_conversion_rate = coalesce_fraction(goals, shots),
      pass_completion_rate = coalesce_fraction(passes_completed, passes_attempted),
      # successful_takeon_rate = coalesce_fraction(successful_takeons, takeons_attempted)
      goals_xg_ratio = safe_divide(goals, xg)
    ) |> 
    dplyr::mutate(
      dplyr::across(
        c(xg, npxg, goals),
        list(
          p90 = \(.x) 90 * .x / minutes_played
        )
      )
    )
}

player_team_season_mapping <- player_match_stats |> 
  dplyr::group_by(league, season, team, player, nation) |>
  dplyr::filter(minutes_played > 0L) |> 
  dplyr::summarize(
    dplyr::across(minutes_played, sum),
    matches_played = dplyr::n_distinct(match_id)
  ) |> 
  dplyr::ungroup()

player_season_stats <- summarize_all_metric_columns(player_match_stats)

## Franks et al. used 250 min played for the NBA
## https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L60
MIN_MINUTES_PLAYED <- 270
eligible_player_season_stats <- player_season_stats |> 
  dplyr::filter(minutes_played >= MIN_MINUTES_PLAYED)

eligible_player_match_stats <- player_match_stats |> 
  dplyr::semi_join(
    eligible_player_season_stats,
    by = dplyr::join_by(league, season, team, player, nation)
  ) |> 
  dplyr::arrange(league, season, team, player, nation)
## drop players with 0s for any given metric across any season?
##   looks like they only did that for testing a 1-season evaluation:
##   https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L25
# eligible_player_season_stats |> 
#   pivot_metric_columns() |> 
#   group_by(league, team, player, metric) |> 
#   summarize(has_any_zero = any(value == 0)) |> 
#   ungroup() |> 
#   filter(has_any_zero)
```

```{r}
#| label: data-pull-save
#| include: false
# library(qs)
PROJ_DIR <- 'posts/soccer-meta-analytics'
qs::qsave(eligible_player_season_stats, file.path(PROJ_DIR, 'eligible_player_season_stats.qs'))
qs::qsave(eligible_player_match_stats, file.path(PROJ_DIR, 'eligible_player_match_stats.qs'))
```

After some light wrangling, the data we'll be working with looks like this.

```{r}
#| label: glimpse-data-pull
#| code-fold: false
dplyr::glimpse(eligible_player_match_stats)
#> Rows: 271,416
#> Columns: 27
#> $ league              <chr> "ENG-M-1st", "ENG-M-1st", "ENG-M-1st", "ENG-M-1…
#> $ season              <chr> "2018/19", "2018/19", "2018/19", "2018/19", "20…
#> $ date                <date> 2018-08-12, 2018-08-18, 2018-08-25, 2018-09-02…
#> $ match_id            <chr> "478e9dab", "9b69882c", "0014076a", "c1503e09",…
#> $ team                <chr> "Arsenal", "Arsenal", "Arsenal", "Arsenal", "Ar…
#> $ player              <chr> "Aaron Ramsey", "Aaron Ramsey", "Aaron Ramsey",…
#> $ minutes_played      <dbl> 53, 23, 90, 90, 79, 79, 62, 24, 11, 13, 18, 16,…
#> $ goals               <dbl> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…
#> $ assists             <dbl> 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 2, 0, 0,…
#> $ shots               <dbl> 1, 2, 2, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 3, 1, 0,…
#> $ shots_on_target     <dbl> 1, 1, 1, 2, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0,…
#> $ touches             <dbl> 18, 11, 67, 78, 63, 34, 24, 26, 17, 10, 12, 12,…
#> $ tackles             <dbl> 2, 0, 2, 1, 2, 0, 2, 0, 1, 0, 0, 0, 1, 2, 1, 0,…
#> $ interceptions       <dbl> 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,…
#> $ blocks              <dbl> 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0,…
#> $ xg                  <dbl> 0.0, 0.1, 0.1, 0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.…
#> $ npxg                <dbl> 0.0, 0.1, 0.1, 0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.…
#> $ xa                  <dbl> 0.1, 0.0, 0.2, 0.2, 0.1, 0.4, 0.0, 0.1, 0.0, 0.…
#> $ sca                 <dbl> 1, 1, 5, 7, 4, 3, 0, 1, 0, 0, 0, 1, 1, 3, 1, 0,…
#> $ gca                 <dbl> 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0, 1, 0, 2, 0, 0,…
#> $ passes_completed    <dbl> 9, 6, 48, 51, 49, 26, 16, 16, 13, 5, 11, 7, 8, …
#> $ passes_attempted    <dbl> 13, 9, 61, 66, 58, 31, 20, 21, 15, 7, 12, 10, 8…
#> $ progressive_passes  <dbl> 1, 1, 9, 6, 5, 4, 2, 2, 1, 0, 1, 1, 0, 3, 4, 3,…
#> $ carries             <dbl> 5, 7, 41, 49, 43, 27, 21, 16, 11, 8, 11, 7, 7, …
#> $ progressive_carries <dbl> 1, 0, 5, 2, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 4, 2,…
#> $ takeons_attempted   <dbl> 1, 0, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 2,…
#> $ successful_takeons  <dbl> 1, 0, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,…
```

Easy enough. Now we can dive right in and calculate the meta-metrics of interest.

### Discrimination

We'll beging with the discrimination meta-metric, which means we'll need to calculate "bootstrap variance", $BV$, and, "seasonal variance", $SV$, as shown in @eq-discrimination-short. Starting with the former, we need to first resample player matches within teams, with replacement.

```{r}
#| label: resampled_player_match_stats
#| code-fold: true
#| code-summary: Bootstrap empirical player-seasons
resample_stats <- function(player_match_stats) {
  
  match_ids <- player_match_stats |>
    dplyr::distinct(league, season, team, date, match_id) |> 
    dplyr::arrange(league, season, team, date)
  
  ## can't just specify to resample 38 matches per team since different leagues 
  ## have different season lengths (Bundesliga)
  resampled_match_ids <- match_ids |> 
    dplyr::select(league, season, team, match_id) |> 
    dplyr::group_by(league, season, team) |> 
    dplyr::summarize(
      match_id = list(match_id)
    ) |> 
    dplyr::ungroup() |> 
    dplyr::mutate(
      match_id = purrr::map(
        match_id,
        \(.x) {
          sample(.x, size = length(.x), replace = TRUE)
        })
    ) |> 
    tidyr::unnest(match_id)
  
  resampled_match_ids |> 
    dplyr::inner_join(
      player_match_stats,
      by = dplyr::join_by(league, season, team, match_id),
      relationship = 'many-to-many'
    )
}

## Franks et al. used 20 bootstrap replicates
## https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L70
N_BOOSTRAPS <- 20
set.seed(42)
resampled_player_match_stats <- purrr::map_dfr(
  rlang::set_names(1:N_BOOSTRAPS),
  \(...) {
    resample_stats(
      player_match_stats = eligible_player_match_stats
    )
  },
  .id = 'bootstrap_id'
) |> 
  dplyr::mutate(bootstrap_id = as.integer(bootstrap_id))
```

And, then, after we aggregate over the bootstraps to create single player-season summaries, we get a data frame that looks like this

```{r}
#| label: resampled_player_season_stats
#| code-fold: true
#| code-summary: Aggregate bootstraps
resampled_player_match_stats <- resampled_player_match_stats |> 
  ## Franks et al. did this
  ## https://github.com/afranks86/meta-analytics/blob/1871d24762184afa69f29a2b5b348431e70b9b2b/basketballReliability.R#L78
  dplyr::filter(minutes_played < (0.75 * MIN_MINUTES_PLAYED))

resampled_player_season_stats <- resampled_player_match_stats |> 
  summarize_all_metric_columns(bootstrap_id) |> 
  dplyr::arrange(bootstrap_id, league, season, team, player, nation)
```

```{r}
#| label: save-resampled_player_season_stats
#| include: false
qs::qsave(resampled_player_season_stats, file.path(PROJ_DIR, 'resampled_player_season_stats.qs'))
```

```{r}
#| label: glimpse-resampled_player_season_stats
#| code-fold: false
dplyr::glimpse(resampled_player_season_stats)
#> Rows: 234,172
#> Columns: 29
#> $ bootstrap_id           <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…
#> $ league                 <chr> "ENG-M-1st", "ENG-M-1st", "ENG-M-1st", "ENG-…
#> $ season                 <chr> "2018/19", "2018/19", "2018/19", "2018/19", …
#> $ team                   <chr> "Arsenal", "Arsenal", "Arsenal", "Arsenal", …
#> $ player                 <chr> "Aaron Ramsey", "Ainsley Maitland-Niles", "A…
#> $ minutes_played         <dbl> 1349, 1053, 1714, 2767, 2213, 1357, 989, 138…
#> $ goals                  <dbl> 2, 2, 3, 11, 4, 3, 0, 5, 0, 0, 7, 0, 2, 20, …
#> $ assists                <dbl> 1, 1, 4, 8, 2, 5, 3, 0, 3, 0, 2, 0, 4, 4, 0,…
#> $ shots                  <dbl> 28, 8, 31, 102, 24, 30, 7, 5, 21, 20, 14, 9,…
#> $ shots_on_target        <dbl> 9, 6, 15, 28, 11, 11, 4, 5, 1, 4, 9, 0, 6, 2…
#> $ touches                <dbl> 1058, 706, 1096, 1335, 2279, 927, 680, 1052,…
#> $ tackles                <dbl> 37, 28, 21, 35, 44, 17, 9, 21, 61, 35, 9, 21…
#> $ interceptions          <dbl> 10, 17, 14, 19, 34, 9, 13, 36, 55, 23, 3, 0,…
#> $ blocks                 <dbl> 4, 33, 21, 26, 23, 25, 6, 20, 41, 29, 9, 9, …
#> $ xg                     <dbl> 2.7, 1.6, 4.2, 11.0, 1.0, 3.9, 0.3, 1.9, 0.6…
#> $ npxg                   <dbl> 2.7, 1.6, 4.2, 11.0, 1.0, 3.9, 0.3, 1.9, 0.6…
#> $ xa                     <dbl> 2.4, 0.9, 5.3, 3.6, 2.0, 4.8, 0.9, 0.5, 0.7,…
#> $ sca                    <dbl> 54, 21, 68, 99, 63, 66, 20, 9, 41, 60, 94, 2…
#> $ gca                    <dbl> 6, 2, 8, 14, 4, 15, 5, 0, 12, 2, 10, 0, 10, …
#> $ passes_completed       <dbl> 733, 444, 619, 677, 1656, 552, 470, 832, 126…
#> $ passes_attempted       <dbl> 906, 561, 847, 933, 2059, 724, 580, 905, 150…
#> $ progressive_passes     <dbl> 97, 59, 120, 120, 221, 83, 46, 37, 137, 223,…
#> $ carries                <dbl> 630, 334, 724, 738, 1085, 454, 333, 602, 978…
#> $ progressive_carries    <dbl> 51, 31, 116, 61, 32, 53, 28, 13, 32, 91, 80,…
#> $ takeons_attempted      <dbl> 21, 31, 80, 96, 12, 45, 9, 2, 27, 33, 35, 4,…
#> $ successful_takeons     <dbl> 15, 20, 43, 63, 6, 11, 8, 2, 12, 25, 25, 2, …
#> $ shot_conversion_rate   <dbl> 0.07142857, 0.25000000, 0.09677419, 0.107843…
#> $ pass_completion_rate   <dbl> 0.8090508, 0.7914439, 0.7308146, 0.7256163, …
#> $ successful_takeon_rate <dbl> 0.7142857, 0.6451613, 0.5375000, 0.6562500, …
```

Next, we calculate the bootstrap variance across the player-season bootstraps. Then we take the average of the bootstrap variance over all player-seasons, grouping by season, to arrive at $BV$. (One value per season and metric.)

```{r}
#| label: bv
#| code-fold: true
#| code-summary: Calculate bootstrap variance, BV
pivot_metric_columns <- function(df) {
  df |> 
    dplyr::select(
      league,
      season,
      team,
      player,
      nation,
      dplyr::any_of(names(ALL_METRICS))
    ) |> 
    tidyr::pivot_longer(
      -c(league, season, team, player, nation),
      names_to = 'metric',
      values_to = 'value'
    )
}

resampled_player_season_variance <- resampled_player_season_stats |> 
  pivot_metric_columns() |> 
  dplyr::group_by(season, team, player, metric) |> 
  dplyr::summarize(
    bv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup()

bv <- resampled_player_season_variance |> 
  dplyr::group_by(season, metric) |> 
  dplyr::summarize(
    bv = mean(bv, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: save-bv
#| include: false
qs::qsave(bv, file.path(PROJ_DIR, 'bv.qs'))
```

```{r}
#| label: glimpse-bv
#| code-fold: false
bv
#> # A tibble: 114 × 3
#>    season  metric                         bv
#>    <chr>   <chr>                       <dbl>
#>  1 2017/18 assists                  1.64    
#>  2 2017/18 blocks                  26.3     
#>  3 2017/18 gca                      4.65    
#>  4 2017/18 shot_conversion_rate     0.00625 
#>  5 2017/18 goals                    2.36    
#>  6 2017/18 interceptions           33.4     
#>  7 2017/18 npxg                     0.761   
#>  8 2017/18 pass_completion_rate     0.000639
#>  9 2017/18 passes_completed     10809.      
#> 10 2017/18 progressive_carries     65.6     
#> # ℹ 104 more rows
```

Next, we move on to the "seasonal variance", $SV$. This is actually pretty trivial, as it's just a direct call to `stats::var` on the empirical player-season aggregates, grouping by season. We end up with one row per season and metric, as we do with $BV$.

```{r}
#| label: sv
#| code-fold: true
#| code-summary: Calculate seasonal variance, SV
pivoted_player_season_stats <- pivot_metric_columns(player_season_stats)

sv <- pivoted_player_season_stats |>
  dplyr::group_by(season, metric) |> 
  dplyr::summarize(
    sv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: save-sv
#| include: false
qs::qsave(sv, file.path(PROJ_DIR, 'sv.qs'))
```

```{r}
#| label: glimpse-sv
#| code-fold: false
sv
#> # A tibble: 114 × 3
#>    season  metric                        sv
#>    <chr>   <chr>                      <dbl>
#>  1 2017/18 assists                   4.33  
#>  2 2017/18 blocks                  186.    
#>  3 2017/18 gca                      19.3   
#>  4 2017/18 shot_conversion_rate      0.0120
#>  5 2017/18 goals                    12.4   
#>  6 2017/18 interceptions           319.    
#>  7 2017/18 npxg                      7.27  
#>  8 2017/18 pass_completion_rate      0.0112
#>  9 2017/18 passes_completed     231962.    
#> 10 2017/18 progressive_carries     944.    
#> # ℹ 104 more rows
```

Now, the easy part---bringing $BV$ and $SV$ together to calculate discrimination, by season.

```{r}
#| label: discrimination
#| code-fold: true
#| code-summary: Calculate discrimination
discrimination <- bv |> 
  dplyr::inner_join(
    sv,
    by = dplyr::join_by(season, metric)
  ) |> 
  dplyr::mutate(
    discrimination = 1 - bv / sv
  ) |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: save-discrimination
#| include: false
qs::qsave(discrimination, file.path(PROJ_DIR, 'discrimination.qs'))
```

```{r}
#| label: glimpse-discrimination
#| code-fold: false
discrimination
#> # A tibble: 114 × 5
#>    season  metric                         bv          sv discrimination
#>    <chr>   <chr>                       <dbl>       <dbl>          <dbl>
#>  1 2017/18 assists                  1.64          4.33            0.621
#>  2 2017/18 blocks                  26.3         186.              0.859
#>  3 2017/18 gca                      4.65         19.3             0.759
#>  4 2017/18 shot_conversion_rate     0.00625       0.0120          0.481
#>  5 2017/18 goals                    2.36         12.4             0.810
#>  6 2017/18 interceptions           33.4         319.              0.895
#>  7 2017/18 npxg                     0.761         7.27            0.895
#>  8 2017/18 pass_completion_rate     0.000639      0.0112          0.943
#>  9 2017/18 passes_completed     10809.       231962.              0.953
#> 10 2017/18 progressive_carries     65.6         944.              0.931
#> # ℹ 104 more rows
```

### Stability

For stability, in addition to $BV$ and $SV$, we need to calculate "within player" variance, $WV$, and the "total variance", $TV$.[^3]

[^3]: Note that these are convenient short names as, in reality, $WV$ is the within player variance prior to subtracting out the relevant sampling variance, $BV$, and $TV$ is the total variance prior to subtracting out the same sampling variance, $BV$.

We start with $WV$. Like $SV$, the calculation is actually fairly straightforward. We group on the appropriate columns, calculate variance with `stats::var()`, group again on a subset of the prior columns, then calculate the average variance with `stats::mean()`.

```{r}
#| label: wv
#| code-fold: true
#| code-summary: Calculate within player variance, WV
within_player_variance <- pivoted_player_season_stats |> 
  ## should check for players with the same name
  dplyr::group_by(league, team, player, metric) |>
  dplyr::summarize(
    seasons_played = dplyr::n(),
    wv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup()

wv <- within_player_variance |>
  ## Franks et al. don't have something quite like this, where they filter for
  ##   a minimum number of seasons played. I think they didn't find it necessary
  ##   after dropping player who have ever had zeros, and because they were working
  ##   with 20 seasons of NBA data. (I'm working with 6.)
  dplyr::filter(
    seasons_played >= 3L
  ) |> 
  dplyr::group_by(metric) |> 
  dplyr::summarize(
    wv = mean(wv, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(metric)
```

```{r}
#| label: save-wv
#| include: false
qs::qsave(wv, file.path(PROJ_DIR, 'wv.qs'))
```

```{r}
#| label: glimpse-wv
#| code-fold: false
wv
#> # A tibble: 19 × 2
#>    metric                           wv
#>    <chr>                         <dbl>
#>  1 assists                     2.71   
#>  2 blocks                     96.2    
#>  3 gca                        10.0    
#>  4 shot_conversion_rate        0.00954
#>  5 goals                       5.75   
#>  6 interceptions             122.     
#>  7 npxg                        2.85   
#>  8 pass_completion_rate        0.00721
#>  9 passes_completed       102682.     
#> 10 progressive_carries       400.     
#> 11 progressive_passes       1346.     
#> 12 shots                     183.     
#> 13 shots_on_target            29.1    
#> 14 successful_takeon_rate      0.0511 
#> 15 successful_takeons        124.     
#> 16 tackles                   239.     
#> 17 touches                220064.     
#> 18 xa                          1.57   
#> 19 xg                          3.71
```

Note that there is just one record per metric.[^4]

[^4]: This agrees with the notation indicated in @eq-stability-full, where there is just one subscript, for metric $m$. Compare this to the two subscripts for both season $s$ and metric $m$ in @eq-discrimination-full. Accordingly, our `discrimination` variable has one row per season and metric.

To finsh our variance calculations, we calculate "total variance", $TV$. This is the most straightforward of them all, as it involves just a call to `stats::var()` for each metric on the empirical player-season stats.

```{r}
#| label: tv
#| code-fold: true
#| code-summary: Calculate total variance, TV
tv <- pivoted_player_season_stats |> 
  dplyr::group_by(metric) |>
  dplyr::summarize(
    tv = var(value, na.rm = TRUE)
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(metric)
```

```{r}
#| label: save-tv
#| include: false
qs::qsave(tv, file.path(PROJ_DIR, 'tv.qs'))
```

```{r}
#| label: glimpse-tv
#| code-fold: false
tv
#> # A tibble: 19 × 2
#>    metric                          tv
#>    <chr>                        <dbl>
#>  1 assists                     4.16  
#>  2 blocks                    177.    
#>  3 gca                        17.9   
#>  4 shot_conversion_rate        0.0128
#>  5 goals                      11.5   
#>  6 interceptions             252.    
#>  7 npxg                        6.86  
#>  8 pass_completion_rate        0.0179
#>  9 passes_completed       236881.    
#> 10 progressive_carries       856.    
#> 11 progressive_passes       2914.    
#> 12 shots                     427.    
#> 13 shots_on_target            65.2   
#> 14 successful_takeon_rate      0.0787
#> 15 successful_takeons        254.    
#> 16 tackles                   460.    
#> 17 touches                460123.    
#> 18 xa                          3.15  
#> 19 xg                          9.27
```

Finally, we bring $BV$, $WV$ and $TV$ together to calculate stability. Note that we average $BV$ across all seasons, arriving at one value per metric, since stability is calculated only per metric, not per metric and per season.

```{r}
#| label: stability
#| code-fold: true
#| code-summary: Calculate stability
average_bv <- bv |> 
  dplyr::group_by(metric) |> 
  dplyr::summarize(
    bv = mean(bv)
  ) |> 
  dplyr::ungroup()

stability <- average_bv |> 
  dplyr::inner_join(
    tv,
    by = dplyr::join_by(metric)
  ) |>
  dplyr::inner_join(
    wv,
    by = dplyr::join_by(metric)
  ) |> 
  dplyr::mutate(
    stability = 1 - (wv - bv) / (tv - bv)
  ) |> 
  dplyr::arrange(metric)
```

```{r}
#| label: save-stability
#| include: false
qs::qsave(stability, file.path(PROJ_DIR, 'stability.qs'))
```

```{r}
#| label: glimpse-stability
#| code-fold: false
stability
#> # A tibble: 19 × 5
#>    metric                          bv          tv           wv stability
#>    <chr>                        <dbl>       <dbl>        <dbl>     <dbl>
#>  1 assists                    1.66         4.16        2.71        0.580
#>  2 blocks                    25.8        177.         96.2         0.533
#>  3 gca                        4.64        17.9        10.0         0.592
#>  4 shot_conversion_rate       0.00707      0.0128      0.00954     0.569
#>  5 goals                      2.38        11.5         5.75        0.629
#>  6 interceptions             27.8        252.        122.          0.577
#>  7 npxg                       0.746        6.86        2.85        0.656
#>  8 pass_completion_rate       0.00108      0.0179      0.00721     0.635
#>  9 passes_completed       10527.      236881.     102682.          0.593
#> 10 progressive_carries       61.5        856.        400.          0.574
#> 11 progressive_passes       194.        2914.       1346.          0.576
#> 12 shots                     31.7        427.        183.          0.618
#> 13 shots_on_target            8.17        65.2        29.1         0.634
#> 14 successful_takeon_rate     0.0254       0.0787      0.0511      0.519
#> 15 successful_takeons        25.2        254.        124.          0.568
#> 16 tackles                   48.3        460.        239.          0.537
#> 17 touches                20370.      460123.     220064.          0.546
#> 18 xa                         0.538        3.15        1.57        0.607
#> 19 xg                         0.944        9.27        3.71        0.668
```

## Results

Using the 2022/23 season as our choice for discrimination, let's make a scatter plot of the discriminaton and stability of our metrics, akin to the plots made by Franks et al.

```{r}
#| label: meta_metrics
#| include: false
meta_metrics <- dplyr::inner_join(
  discrimination |> dplyr::select(season, metric, sv, bv, discrimination),
  stability |> dplyr::select(metric, tv, wv, stability),
  by = dplyr::join_by(metric),
  relationship = 'many-to-one'
) |> 
  dplyr::select(
    season,
    metric,
    tv,
    sv,
    bv,
    wv,
    discrimination,
    stability
  ) |> 
  dplyr::arrange(season, metric)
```

```{r}
#| label: plot-meta_metrics
#| include: false
library(ggplot2)
library(sysfonts)
library(showtext)
library(ggtext)
library(htmltools)

TAG_LABEL <- htmltools::tagList(
  htmltools::tags$span(htmltools::HTML(enc2utf8("&#xf099;")), style = 'font-family:fb'),
  htmltools::tags$span("@TonyElHabr"),
)
CAPTION_LABEL <- '**Data**: Opta via fbref.<br/>**Inspiration**: *“Meta-Analytics: Tools for Understanding the Statistical Properties of Sports Metrics”*, Franks et al. (2017)'
SUBTITLE_LABEL <- 'Big 5 Leagues, 2017/18 - 2022/23'
PLOT_RESOLUTION <- 300
WHITISH_FOREGROUND_COLOR <- 'white'
COMPLEMENTARY_FOREGROUND_COLOR <- '#cbcbcb' # '#f1f1f1'
BLACKISH_BACKGROUND_COLOR <- '#1c1c1c'
COMPLEMENTARY_BACKGROUND_COLOR <- '#4d4d4d'
FONT <- 'Titillium Web'
sysfonts::font_add_google(FONT, FONT)
## https://github.com/tashapiro/tanya-data-viz/blob/main/chatgpt-lensa/chatgpt-lensa.R for twitter logo
sysfonts::font_add('fb', 'Font Awesome 6 Brands-Regular-400.otf')
showtext::showtext_auto()
showtext::showtext_opts(dpi = PLOT_RESOLUTION)

ggplot2::theme_set(ggplot2::theme_minimal())
ggplot2::theme_update(
  text = ggplot2::element_text(family = FONT),
  title = ggplot2::element_text(size = 20, color = WHITISH_FOREGROUND_COLOR),
  plot.title = ggtext::element_markdown(face = 'bold', size = 20, color = WHITISH_FOREGROUND_COLOR),
  plot.title.position = 'plot',
  plot.subtitle = ggtext::element_markdown(size = 16, color = COMPLEMENTARY_FOREGROUND_COLOR),
  axis.text = ggplot2::element_text(color = WHITISH_FOREGROUND_COLOR, size = 14),
  # axis.title = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),
  axis.title.x = ggtext::element_markdown(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),
  axis.title.y = ggtext::element_markdown(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),
  axis.line = ggplot2::element_blank(),
  strip.text = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0),
  panel.grid.major = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),
  panel.grid.minor = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),
  panel.grid.minor.x = ggplot2::element_blank(),
  panel.grid.minor.y = ggplot2::element_blank(),
  plot.margin = ggplot2::margin(10, 20, 10, 20),
  plot.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR),
  plot.caption = ggtext::element_markdown(color = WHITISH_FOREGROUND_COLOR, hjust = 0, size = 10, face = 'plain'),
  plot.caption.position = 'plot',
  plot.tag = ggtext::element_markdown(size = 12, color = WHITISH_FOREGROUND_COLOR, hjust = 1),
  plot.tag.position = c(0.99, 0.99),
  panel.spacing.x = grid::unit(2, 'lines'),
  panel.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR)
)

p <- meta_metrics |> 
  dplyr::filter(season == '2022/23') |> 
  dplyr::mutate(
      metric = ALL_METRICS[metric]
  ) |> 
  ggplot2::ggplot() +
  ggplot2::aes(
    x = discrimination,
    y = stability
  ) +
  ggplot2::geom_abline(
    linetype = 2,
    color = COMPLEMENTARY_FOREGROUND_COLOR
  ) +
  ggplot2::geom_point(
    size = 2.5,
    color = WHITISH_FOREGROUND_COLOR
  ) +
  ggrepel::geom_text_repel(
    seed = 42,
    family = FONT,
    size = 11 / .pt,
    min.segment.length = 0,
    force = 100,
    max.overlaps = Inf,
    colour = WHITISH_FOREGROUND_COLOR,
    segment.colour = COMPLEMENTARY_FOREGROUND_COLOR,
    ggplot2:: aes(label = metric)
  ) +
  # coord_equal(xlim = c(0, 1), ylim = c(0, 1))
  ggplot2::scale_x_continuous(limits = c(0.25, 1)) +
  ggplot2::scale_y_continuous(limits = c(0.25, 1)) +
  ggplot2::labs(
    title = 'Meta-metrics for soccer',
    subtitle = SUBTITLE_LABEL,
    tag = TAG_LABEL,
    caption = CAPTION_LABEL,
    x = 'Discrimination',
    y = 'Stability'
  )
p
ggplot2::ggsave(
  p,
  filename = file.path(PROJ_DIR, 'discrimination-v-stability.png'),
  width = 7,
  height = 7
)
```

We can make the following observations:

-   Tallying statistics based on total playing time--like goals, shots, tackles, and interceptions--tend to be highly discriminative and not as stable. This makes sense---such statistics have large between-player variance (think about the number of shots that a central defender takes compared to a striker) and, when aggregated for each player over the course of a season, provide strong signal for different player types, i.e. positions.

    -   Indeed, Franks et al. found the same for NBA and NHL statistics.

-   Of the cluster of statistics that are more discriminative than stable, xG nudges out as the most stable.

-   Shot conversion rate (i.e. goals divided by shots) stands out as the only metric that is relatively more stable than discriminative.

-   It's interesting to see that our minutes-adjusted metrics, goals/90 and xG/90, seem to be equally stable and discriminative. The stability of these metrics is significantly improved compared to their non-minutes-adjusted counterparts, goals and xG. This speaks to the between-player noise-minimizing benefits of comparing players on an equal minute basis.

## Conclusion

TODO: Emphasize that discrimination is within season, whereas stability is across seasons

> discrimination, which is a meta-metric that describes variation within a single season, it is important to understand how much an individual player's metric varies from season to season.

> Our discrimination meta-metric quantifies how useful a metric is for distinguishing between players within a given season, whereas our stability meta-metric measures how much a metric varies season to season due to changes in context and player skill after removing chance variation

[Repository](https://github.com/afranks86/meta-analytics)

