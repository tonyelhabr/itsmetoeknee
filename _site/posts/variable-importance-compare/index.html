<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tony ElHabr">
<meta name="dcterms.date" content="2020-07-13">
<meta name="description" content="Permuation, SHAP, and More">

<title>Tony’s Blog - Comparing Variable Importance Functions (For Modeling)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/img/keyboard.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-79842648-2', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>


<link rel="stylesheet" href="../../styles.css">
<meta name="twitter:title" content="Tony’s Blog - Comparing Variable Importance Functions (For Modeling)">
<meta name="twitter:description" content="Permuation, SHAP, and More">
<meta name="twitter:image" content="https://itsmetoeknee.netlify.app/posts\variable-importance-compare\viz_diamonds_c_rnks.png">
<meta name="twitter:site" content="@TonyElHabr">
<meta name="twitter:image-height" content="2400">
<meta name="twitter:image-width" content="2400">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tony’s Blog</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html">
 <span class="menu-text">Projects</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tonyelhabr"><i class="bi bi-github" role="img" aria-label="github">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/TonyElHabr"><i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-color-scheme-toggle nav-link" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#setup" id="toc-setup" class="nav-link active" data-scroll-target="#setup">Setup</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Comparing Variable Importance Functions (For Modeling)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">r</div>
  </div>
  </div>

<div>
  <div class="description">
    Permuation, SHAP, and More
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Tony ElHabr </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 13, 2020</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>I’ve been doing some machine learning recently, and one thing that keeps popping up is the need to explain the models and their components. There are a variety of ways to go about explaining model features, but probably the most common approach is to use <a href="https://stats.stackexchange.com/questions/332960/what-is-variable-importance">variable (or feature) importance</a> scores. Unfortunately, computing variable importance scores isn’t as straightforward as one might hope—there are a variety of methodologies! Upon implementation, I came to the question “How similar are the variable importance scores calculated using different methodologies?” <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> I think it’s important to know if the different methods will lead to drastically different results. If so, then the choice of method is a source of bias in model interpretation, which is not ideal.</p>
<p>This post isn’t intended to be a deep-dive into <a href="https://christophm.github.io/interpretable-ml-book/">model interpretability</a> or variable importance, but some concepts should be highlighted before attempting to answer this question. Generally, variable importance can be categorized as either being <a href="https://topepo.github.io/caret/variable-importance.html">“model-specific”</a> or <a href="https://christophm.github.io/interpretable-ml-book/agnostic.html">“model-agnostic”</a>. Both depend upon some kind of loss function, e.g.&nbsp;<a href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">root mean squared error (RMSE)</a>, <a href="https://en.wikipedia.org/wiki/Confusion_matrix">classification error</a>, etc. The loss function for a model-specific approach will generally be “fixed” by the software and package that are used<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, while model-agnostic approaches tend to give the user flexibility in choosing a loss function. Finally, within model-agnostic approaches, there are different methods, e.g.&nbsp;<a href="https://christophm.github.io/interpretable-ml-book/feature-importance.html">permutation</a> and <a href="https://christophm.github.io/interpretable-ml-book/shap.html">SHAP (Shapley Additive Explanations)</a>.</p>
<p>So, to summarize, variable importance “methodologies” can be broken down in several ways:</p>
<ol type="1">
<li>model-specific vs.&nbsp;model-agnostic approach</li>
<li>loss function 3 . model agnostic method (given a model agnostic approach)</li>
</ol>
<p>I’m going to attempt to address (1) and (3) above. I’m leaving (2) out because (a) I think the results won’t differ too much when using different loss functions (although I haven’t verified this assumption) and (b) for the sake of simplicity, I don’t want to be too exhaustive in this analysis. <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>I also want to evaluate how variable importance scores differ across more than one of each of the following:</p>
<ol type="1">
<li>model type (e.g.&nbsp;linear regression, decision trees, etc.)</li>
<li>type of target variables (continuous or discrete )</li>
<li>data set</li>
</ol>
<p>While evaluating the sensitivity of variable importance score to different methodologies is the focus of this analysis, I think it’s important to test how the findings hold up when (1) varying model types, (2) varying target variables, and (3) varying the data itself. This should help us highlight any kind of bias in the results due to choice of model type and type of target variable. Put another way, it should help us quantify the robustness the conclusions that are drawn. If we find that the scores are similar under variation, then we can be more confident that the findings can be generalized.</p>
<p>Additionally, I’m going to use more than one package for computing variable importance scores. As with varying model types, outcome variables, and data, the purpose is to highlight and quantify possible bias due to choices in this analysis—in this case, the choice of package. Are the results of a permutation-based variable importance calculation the same when using different packages (holding all else equal)?</p>
<p>Specifically, I’ll be using the <a href="https://cran.r-project.org/web/packages/vip/index.html"><code>{vip}</code></a> and <a href="https://cran.r-project.org/web/packages/DALEX/index.html"><code>{DALEX}</code></a> packages. The <code>{vip}</code> package is my favorite package to compute variable importance scores using Ris because it is capable of doing both types of calculations (model-specific and model-agnostic) for a variety of model types. But other packages are also great. <code>{DALEX}</code> package specializes in model-agnostic model interpretability and can do a lot more than just variable importance calculations.</p>
<section id="setup" class="level1">
<h1>Setup</h1>
<p>For data, I’m going to be using two data sets from <code>{ggplot2}</code>. <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>increase computation time. (b) I’ve excluded two of the categorical features—<code>clarity</code> and <code>color</code>, both of which are categorical with a handful of levels. I’ve done this in order to reduce the number of variables involved and, consequently, to speed up computation. (This is just an example after all!) (c) To test how variable importance scores differ for a continuous target variable, I’ll be defining models that predict <code>price</code> as a function of all other variables. (d) For discrete predictions, the target is a binary variable <code>grp</code> that I’ve added. It is equal to <code>'1. Good'</code> when <code>cut %in% c('Idea', 'Premium')</code> and <code>2. Bad'</code> otherwise. It just so happens that <code>grp</code> is relatively evenly balanced between the two levels, so there should not be any bias in the results due to class imbalance.</p>
<p>I made modifications to both, so see the footnotes and/or code if you’re interested in the detailI made modifications to both, so see the footnotes and/or code if you’re interested in the details.</p>
<p>For model types, I’m going to trial the following:</p>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Generalized_linear_model">generalized linear model (linear and logistic regression)</a> with <code>stats::lm()</code> and <code>stats::glm()</code> respective ly</li>
<li><a href="https://en.wikipedia.org/wiki/Regularized_least_squares">generalized linear model with regularization</a> using the <a href="https://cran.r-project.org/web/packages/glmnet/index.ht%20ml"><code>{glmnet}</code> package</a></li>
<li>bagged tree (<a href="https://en.wikipedia.org/wiki/Random_forest">random forest</a>) using the <a href="https://cran.r-project.org/web/packages/ranger/index.h%20tml"><code>{ranger}</code> package</a></li>
<li>boosted tree (extreme <a href="https://en.wikipedia.org/wiki/Gradient_boosting">gradient boosting</a>) using the <a href="https://cran.r-project.org/web/packages/xgboost/index.html"><code>{xgboost}</code> package</a></li>
</ol>
<p>With <code>glmnet::glmnet()</code>, I’m actually not going to use a penalty, so (I think) it should return the same results as <code>lm()</code>/<code>glm()</code>. <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> For <code>{ranger}</code> and <code>{xgboost}</code>, I’m going to be using defaults for all parameters. <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<ol type="1">
<li><code>{vip}</code>’s model-specific scores with (<code>vip::vip(method = 'mod l')</code>)</li>
<li><code>{vip}</code>’s permutation-based scores (with <code>vip::vip(method = 'permute')</code>)</li>
<li><code>{vip}</code>’s SHAP-based values (with <code>vip::vip(method = 'shap')</code>)</li>
<li><a href="https://pbiecek.github.io/ema/featureImportance.html"><code>{DALEX}</code>’s permutation-based scores</a> (with <code>DALEX::variable_importance()</code>)</li>
</ol>
<p>Note that the model-specific vs.&nbsp;model-agnostic concern is addressed in comparing method (1) vs.&nbsp;methods (2)-(4). I’ll be consistent with the loss function in variable importance computations for the model-agnostic methods–minimization of RMSE for a continuous target variable and <a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">sum of squared errors (SSE)</a> for a discrete target variable. <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
</section>
<section id="results" class="level1">
<h1>Results</h1>
<p>The following handful of plots illustrate normalized variable importance scores and ranks derived from the scores by data set and type of target variable.</p>
<p>First up is the results for the <code>diamonds</code> data set with a continuous target variable.</p>
<p>me: the model-specific scores differ relatively strongly from the rest of the scores given a specific model type. (See the numbers in the parentheses in the first column in each facet labeled <code>vip_model</code> compared to those in the other columns of each facet. <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> For example, the model-specific variable importance score for the <code>carat</code> feature for the <code>{glm}</code> model type is 49%, while the same score for the SHAP variable importance method (<code>vip_shap</code>) is 35%. To be honest, this is not too surprising. The model-specific methods are exactly that—specific to the model type—which suggests that they may strongly dissimilar to the model-agnostic approaches. Nonetheless, despite the scores themselves having some notable variance, the rankings derived from the scores are relatively similar across a given model type (and, arguably, across all model types).</p>
<p>As a second observation, there is some disagreement between the <code>{glm}</code> and <code>{glmnet}</code> model types and the <code>{ranger}</code> and <code>{xgboost}</code> model types about which feature is the most important: the former two identify <code>carat</code> has being the most important, while the latter two prioritize <code>y</code>.</p>
<p>Thirdly–and lastly for this plot—it’s nice to see that the <code>vip_permute</code> and <code>dalex</code> methods produce nearly identical results for each model type, with the exception of <code>{glmnet}</code>. (Hypothetically, these should have nearly identical results since they are both permutation based methods.) Notably, I implemented the <code>explain()</code> function for <code>{glmnet}</code> myself since the <code>{DALEX}</code> package does not export one, so that is probably the reason for the discrepancy.</p>
<p>Now let’s look at the the results when predicting a discrete target variable with the same data set.</p>
<p><img src="viz_diamonds_d_rnks.png" class="img-fluid"></p>
<p>Compared to the results for a continuous target variable, we see greater variation across the model types—the rankings from <code>{glm}</code> and <code>{glmnet}</code> are nearly identical, but they are different from those of <code>{xgboost}</code>, and all are different from those of <code>{ranger}</code>. <code>{ranger}</code> has an additional level of variation—lack of agreement among the methodologies.</p>
<p>Additionally, we observe that the scores for our two permutation implementations— <code>vip_permute</code> and <code>dalex</code>—are <strong>very</strong> different. I think this might have to do with how I’ve chosen to normalize scores (i.e.&nbsp;using absolute value to convert negative scores to positive ones prior to 0-1 normalization) or something I’ve over-looked that is specific to classification settings. If something that can be attributed to me (and not the underlying methods) is really the source of discrepancies, then we should be less concerned with the variation in scores and ranks since it seems most strongly associated with the <code>vip_permute</code>-<code>dalex</code> differences.</p>
<p>Before we can begin to generalize any deductions (possibly biased by our single data set), let’s take a look at the results for the second data set, <code>mpg</code>. First is the results for the continuous target variable.</p>
<p><img src="viz_mpg_c_rnks.png" class="img-fluid"></p>
<p>There is consensus on what the most important variable is—<code>cyl</code>—but beyond that, the results are somewhat varied across the board. One might argue that there is going to be lack of agreement among methods (and model types), it’s preferable that the discrepancies occur among lower ranks, as seen here. On the other hand, we’d surely like to see more consensus among variables ranked among the top half or so.</p>
<p>And now for the results when ranking with models targeting a discrete variable.</p>
<p><img src="viz_mpg_d_rnks.png" class="img-fluid"></p>
<p>There is some pretty strong variation in the <code>{ranger}</code> results. Also, there are discrepancies between the two permutation methods (<code>vip_permute</code> and <code>dalex</code>), which we also noted in the discrete results for <code>diamonds</code> as well. This makes me think again that the issue is due to something I’ve done and not something that could be attributed to the underlying methods. Aside from these, I would say that the results within each model type are pretty coherent (more so than those with the continuous outcome.)</p>
<p>Even without performing any kind of similarity evaluation, we can argue that, in general, the rankings computed by the different methods are relatively similar across the two data sets (<code>diamonds</code> and <code>mpg</code>) and the two types of target variables (continuous and discrete). But why stop there? After all, we <strong>can</strong> quantify the similarities between ranks.</p>
<p><img src="viz_cor_by_engine.png" class="img-fluid"></p>
<p>The plot above shows the pairwise correlations among the variable importance ranks computed for each package-function combo, averaged over the two data sets and over the models for the two types of target variables—continuous and discrete. <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> While nothing immediately jumps out from this plot, I think the most notable thing is that the <code>{ranger}</code> scores seem to vary the most across the different variable importance methodologies, bottoming out at 74% for the correlation between the SHAP (<code>vip_shap</code>) and model-specific (<code>vip_model</code>) methodologies. On the other hand, <code>{xgboost}</code> seems to have the most “agreement” and least variance in its scores.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Overall, we might say that rankings of variable importance based on normalized variable importance scores in this analysis showed that differences will arise when evaluating different methodologies, but the differences may not be strong enough to change any deductions that one might draw. Of course, this will depend on the context. A small differences could make a huge difference in a field like medicine!</p>
<p>I wouldn’t go so far as to say that these insights can be generalized—among other things, I think I would need to evaluate a much larger variety of data sets—but I think it’s good to be conscious how much the results can vary. It’s ultimately up to the user whether the differences are significant.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>After all, I want to make sure my results aren’t sensitive to some kind of bias (unintentional in this case).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This isn’t an academic paper after all!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This isn’t an academic paper after all!<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Modifications include the following: (a) I’ve excluded <code>manufacturer</code>, <code>model</code>, <code>trans</code>, and <code>class</code>. (b) For continuous predictions, I’ll predict <code>displ</code> as a function of all other variables. (c) For discrete predictions, I’ve created a binary variable <code>grp</code> based on <code>class</code>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>(I haven’t actually checked the source for <code>{glmnet}</code> and compared it to that of <code>lm()</code>/<code>glm()</code>. Differences may arise due to underlying differences in the algorithm for least squares.)<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>I should say that I’m using the <code>{tidymodels}</code> package to assist with all of this. It really shows off its flexibility here, allowing me to switch between models only having to change-out one line of code!Finally, for variable importance scores (which is really the focus), I’m going to use the following packages and functi ons.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Yes, SSE is certainly not the best measure of loss for classification. Nonetheless, when dealing with a binary outcome variable, as is done here, it can arguably be cceptable.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Don’t be deceived by the fill contours, which are based on the rankings–the number in front of the parentheses.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>I could have split (or “facetted”) in a different way–e.g.&nbsp;by type of target variable instead of by package-function combo—but I think splitting in this way makes the most sense because the type of model—<code>{glm}</code>, <code>{ranger}</code>, etc.—is likely the biggest source of variation.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>