{
  "hash": "13ac4067fa2e0b1bc8aba585e3d29012",
  "result": {
    "markdown": "---\ntitle: Does completing your passes even matter?\ndescription: Identifying where incomplete passes can have positive impact on the pitch.\ndate: 2024-04-01\ndraft: true\ncategories:\n  - r\n  - soccer\n  - observablejs\nexecute: \n  code-fold: show\n  eval: true\n  include: true\n  echo: false\n---\n\n\n# Introduction\n\nI've written a lot about expected goals (xG) in soccer, but I haven't yet talked much about [possession value (PV) models](https://statsbomb.com/soccer-metrics/possession-value-models-explained/)[^1], another big topic in soccer analytics. What are they? Well, every PV model is different, but they all generally try assign value to every on-ball action on the pitch. Such a model can help inform decisions about how to improve player and team performance.\n\n[^1]: Except in [this post](/posts/soccer-league-strength/), where I only briefly mention that I use a PV model.\n\nI heard someone recently say something like \"PV models in soccer basically come down to ball progression\". That's an interesting thought, and I add a hunch that it probably isn't too wrong.\n\nOne way of getting at that idea is too look at how your PV model treats incomplete passes.\n\n1.  Does it say that all long passes are \"good\"? What role does the starting position of the pass play? (i.e. Are balls crossed into the 18-yard box from the wing treated similarly to goal kicks launched into the opponent's box?)\n2.  How does PV for an unsuccessful pass compare to a successful one, holding all else equal?\n\nI attempt to answer some of these questions with [a VAEP model](https://dtai.cs.kuleuven.be/sports/vaep)--an [open-source PV model](https://fivethirtyeight.com/features/possession-is-the-puzzle-of-soccer-analytics-these-models-are-trying-to-solve-it/).[^2][^3]\n\n[^2]: My model is trained on 2013/14 - 2023/24 English Premier League data.\n\n[^3]: While all PV models [are similar conceptually](https://statsbomb.com/soccer-metrics/possession-value-models-explained/), it's important to identify how they differ in their target variables. VAEP specifically tries to quantify the difference in the probability of scoring and conceding in the next 10 actions. In contrast, expected threat (xT)--perhaps the most well known PV model--tries to quantify only the probability of scoring in the next 5 actions, not accounting for the conceding probability, which can undermine the \"risk\" associated with incomplete passes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Possession Value (PV) for Passes\n\n## Completed Passes\n\nWe'll want to eventually look at the PV of incomplete passes, but it's probably easier to start with completed passes, as we have pretty strong intuition about them--pass the ball successfully closer to the goal, and you're most likely helping your team (i.e. positive PV).\n\n### From the Center Spot, To Anywhere on the Pitch\n\nIn the interactive 8x12 pitch below, the blue cell illustrates where a pass is made, and the colored cells illustrate the average possession value (PV) associated with all historical successful passes made to that area. Hovering over a cell shows the PV value above the pitch as well.[^4]\n\n[^4]: Do not be alarmed by the small values! Values between 0.02 and 0.02 is very common for PV models.\n\nOverall, I'd say that this illustration matches intuition--forward completed passes into the final third should be assigned non-trivial positive value.\n\n\n```{ojs}\n//| include: true\n//| fig-cap: A heatmap showing the average possession value (PV) of historical completed passes from the center spot (annotated in blue) to all areas on the pitch. The relative frequency of successful passes from the center spot to each other cell is shown as a percentage. The exact PV value associated with a complete pass ending at the hover point can be viewed above the pitch. Black cells represent areas to which successful passes from the center spot have never been made.\n{\n  const chart = d3.create(\"div\").style(\"background-color\", \"8f8f8f\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-complete-empirical\")\n  title.append(\"p\").html(`PV: <span id='pv-value-complete-empirical'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-complete-empirical\")\n\n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-complete-empirical\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\")\n    .style(\"align-items\", \"center\")\n    .style(\"width\", \"100%\");\n\n  const legendRange = [\n    1.1 * d3.min(colorScaleCompleteRange),\n    1.1 * d3.max(colorScaleCompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n\n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n\n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", \"100%\");\n\n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleComplete(d));\n\n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", `${totalLegendWidth}px`);\n\n  labelRow.selectAll(\"span\")\n    .data(colorScaleCompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleCompleteRange)) {\n        return d + \" <=\";\n      } else if (d === d3.max(colorScaleCompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\")\n\n  return chart.node();\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n{\n  const heatmap_complete_empirical = d3_soccer.heatmap(pitch)\n    .colorScale(colorScaleComplete)\n    .enableInteraction(true)\n    .onSelect((x, y, v) => {\n      const cappedValue = Math.min(Math.max(v, -1), 1);\n      d3.select(\"#pv-value-complete-empirical\").text(cappedValue.toFixed(3));\n    })\n    .parent_el(\"#heatmap-complete-empirical\")\n    .interpolate(false);\n\n  d3.select(\"#heatmap-complete-empirical\")\n    .html(\"\")\n    .datum(complete_empirical_pv_data)\n    .call(heatmap_complete_empirical);\n\n  const svg = d3.select(\"#heatmap-complete-empirical\").select(\"svg\");\n\n  const cells = svg.selectAll(\".cell\");\n\n  cells.each(function(d, i) {\n    const cell = d3.select(this);\n    const bbox = this.getBBox();\n\n    d3.select(this.parentNode)\n      .append(\"text\")\n      .attr(\"x\", bbox.x + bbox.width / 2)\n      .attr(\"y\", bbox.y + bbox.height / 2)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"central\")\n      .style(\"font-size\", \"3px\")\n      .style(\"pointer-events\", \"none\")\n      .text((d.prop * 100).toFixed(1) + \"%\");\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", passStartParams.x)\n    .attr(\"y\", passStartParams.y)\n    .attr(\"width\", cellParams.width)\n    .attr(\"height\", cellParams.height)\n    .style(\"stroke\", \"blue\")\n    .style(\"fill\", \"none\")\n    .style(\"stroke-width\", \"1px\");\n}\n```\n\n\nNote that the gradient is for PV, not for relative frequency of completed passes from the center spot. While passes into the box from the center spot have really strong positive PV, they're uncommon because defenders are generally looking to stop those kinds of threatening passes.\n\nThe gradient in the plot below illustrates the relative frequency of successful passes from the center spot directly.\n\n\n```{ojs}\n//| include: true\n//| fig-cap: A heatmap where the gradient and text illustrates the relative frequency of historical successful passes from the center spot (annotated in blue) to all areas on the pitch. Black cells represent areas to which successful passes from the center spot have never been made.\n{\n  const chart = d3.create(\"div\").style(\"background-color\", \"8f8f8f\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-complete-empirical-prop\")\n  chart.append(\"div\").attr(\"id\", \"heatmap-complete-empirical-prop\")\n\n  return chart.node();\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n{\n  const colorScaleSeq = d3.scaleSequential(d3.interpolateRgb(\"white\", \"gold\"))\n    .domain([0, 0.1])\n    .clamp(true)\n  const heatmap_complete_empirical_prop = d3_soccer.heatmap(pitch)\n    .colorScale(colorScaleSeq)\n    .enableInteraction(false)\n    .parent_el(\"#heatmap-complete-empirical-prop\")\n    .interpolate(false);\n\n  d3.select(\"#heatmap-complete-empirical-prop\")\n    .html(\"\")\n    .datum(complete_empirical_prop_data)\n    .call(heatmap_complete_empirical_prop);\n\n  const svg = d3.select(\"#heatmap-complete-empirical-prop\").select(\"svg\");\n\n  const cells = svg.selectAll(\".cell\");\n\n  cells.each(function(d, i) {\n    const cell = d3.select(this);\n    const bbox = this.getBBox();\n\n    d3.select(this.parentNode)\n      .append(\"text\")\n      .attr(\"x\", bbox.x + bbox.width / 2)\n      .attr(\"y\", bbox.y + bbox.height / 2)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"central\")\n      .style(\"font-size\", \"3px\")\n      .style(\"pointer-events\", \"none\")\n      .text((d.prop * 100).toFixed(1) + \"%\");\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", passStartParams.x)\n    .attr(\"y\", passStartParams.y)\n    .attr(\"width\", cellParams.width)\n    .attr(\"height\", cellParams.height)\n    .style(\"stroke\", \"blue\")\n    .style(\"fill\", \"none\")\n    .style(\"stroke-width\", \"1px\");\n}\n```\n\n\n### From Anywhere on the Pitch, To Anywhere on the Pitch\n\nNow, to give the full picture, the interactive pitch below dynamically updates to show the average PV values associated with a pass starting from **any** cell that you hover over. The minimum and maximum PV achieved with a successful pass from the hovered spot are shown in the text above the pitch.\n\n\n```{ojs}\n//| include: true\n//| fig-cap: A heatmap showing the average possession value (PV) of historical completed pass from the hover spot to all areas on the pitch. The highest and lowest PV values across all end points associated with a completed pass from the hover point are shown above the pitch. Black cells represent areas to which successful passes from the hover spot have never been made.\n{\n  const chart = d3.create(\"div\").style(\"background-color\", \"8f8f8f\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-complete-empirical-nested\")\n  title.append(\"p\").html(`min PV: <span id='pv-min-complete-empirical-nested'>0</span>, max PV: <span id='pv-max-complete-empirical-nested'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-complete-empirical-nested\")\n  \n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-complete-empirical-nested\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\")\n    .style(\"align-items\", \"center\")\n    .style(\"width\", \"100%\");\n  \n  const legendRange = [\n    1.1 * d3.min(colorScaleCompleteRange),\n    1.1 * d3.max(colorScaleCompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n  \n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n  \n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", \"100%\");\n  \n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleComplete(d));\n  \n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", `${totalLegendWidth}px`);\n  \n  \n  labelRow.selectAll(\"span\")\n    .data(colorScaleCompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleCompleteRange)) {\n        return d + \" <=\";\n      } else if (d === d3.max(colorScaleCompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\")\n  \n  return chart.node();\n\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n{  \n  const heatmap_complete_empirical_nested = d3_soccer.heatmap(pitch)\n    .colorScale(d3.scaleLinear().domain([-1, 1]).range([\"white\", \"white\"]))\n    .enableInteraction(true)\n    .onSelect((x, y, v) => {\n      const rawMinValue = d3.min(v, d => d.value);\n      const rawMaxValue = d3.max(v, d => d.value);\n      const minValue = Math.max(rawMinValue, -1);\n      const maxValue = Math.min(rawMaxValue, 1);\n  \n      d3.select(\"#pv-min-complete-empirical-nested\").text(minValue.toFixed(3));\n      d3.select(\"#pv-max-complete-empirical-nested\").text(maxValue.toFixed(3));\n      const cells = d3\n        .select(\"#heatmap-complete-empirical-nested\")\n        .selectAll(\"rect.cell\")\n        .data(v)\n  \n      cells.enter()\n        .merge(cells)\n        .attr(\"x\", d => d.x)\n        .attr(\"y\", d => d.y)\n        .attr(\"width\", d => d.width)\n        .attr(\"height\", d => d.height)\n        .style(\"fill\", d => colorScaleComplete(+d.value));\n\n      cells.each(function(d, i) {\n        const cell = d3.select(this.parentNode);\n        const existingText = cell.select(\"text\")\n        if (!existingText.empty()) {\n          existingText.text((d.prop * 100).toFixed(1) + \"%\");\n        } else {\n          const bbox = this.getBBox();\n          cell.append(\"text\")\n            .attr(\"x\", bbox.x + bbox.width / 2)\n            .attr(\"y\", bbox.y + bbox.height / 2)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"alignment-baseline\", \"central\")\n            .style(\"font-size\", \"3px\")\n            .style(\"pointer-events\", \"none\")\n            .text((d.prop * 100).toFixed(1) + \"%\");\n        }\n      });\n  \n      cells.exit().remove()\n  \n      d3.select(\"#heatmap-complete-empirical-nested\")\n        .selectAll(\"rect.cell\")\n        .data(complete_empirical_nested_pv_data)\n        \n    })\n    .parent_el(\"#heatmap-complete-empirical-nested\")\n    .interpolate(false);\n  \n  d3.select(\"#heatmap-complete-empirical-nested\")\n    .html(\"\")\n    .datum(complete_empirical_nested_pv_data)\n    .call(heatmap_complete_empirical_nested);\n}\n```\n\n\nThere are several take-aways one might have from this view, but the big one that I have is this: As you move your mouse (i.e. the starting point of the pass) from the defender's box to the opponent's box, the consolidate green box of +0.025 PV doesn't change much. It stays basically at around the final quarter of the pitch. So you can't just complete a 30-yard pass from the top of your own box progressing the ball towards the middle of the pitch and expect to get anywhere near the same PV as completing a 30-yard pass from the center of the pitch to near the opponent's 18-yard box. The end point really matters.\n\nThis conclusion gets at our first question--\"Are all long passes good?\"--to which the answer so far is \"not quite\" (in the sense that \"good\" is more than just \"positive PV\" for completed passes). A long completed pass in your own half doesn't boast a huge positive PV. To get a more complete perspective, we'll plot out the PV for incomplete passes to see what the answer is there.\n\n## Incomplete Passes\n\n### From the Center Spot, To Anywhere on the Pitch\n\nLet's start with an example again, looking at PV for unsuccessful passes from the center spot.\n\n\n```{ojs}\n//| include: true\n//| fig-cap: A heatmap showing the average possession value (PV) of historical incomplete passes from the center spot (annotated in blue) to all areas of the pitch. The relative frequency of unsuccessful passes from the center spot to each other cell is shown as a percentage. The exact PV value associated with an incomplete pass ending at the hover point can be viewed above the pitch. Black cells represent areas to which unsuccessful passes from the center spot have never been made.\n{\n  const chart = d3.create(\"div\").style(\"background-color\", \"8f8f8f\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-incomplete-empirical\")\n  title.append(\"p\").html(`PV: <span id='pv-value-incomplete-empirical'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-incomplete-empirical\")\n\n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-incomplete-empirical\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\")\n    .style(\"align-items\", \"center\")\n    .style(\"width\", \"100%\");\n\n  const legendRange = [\n    1.1 * d3.min(colorScaleIncompleteRange),\n    1.1 * d3.max(colorScaleIncompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n\n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n\n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", \"100%\");\n\n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleIncomplete(d));\n\n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", `${totalLegendWidth}px`);\n\n  labelRow.selectAll(\"span\")\n    .data(colorScaleIncompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleIncompleteRange)) {\n        return d + \" <=\";\n      } else if (d === d3.max(colorScaleIncompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\")\n\n  return chart.node();\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n{\n  const heatmap_incomplete_empirical = d3_soccer.heatmap(pitch)\n    .colorScale(colorScaleIncomplete)\n    .enableInteraction(true)\n    .onSelect((x, y, v) => {\n      const cappedValue = Math.min(Math.max(v, -1), 1);\n      d3.select(\"#pv-value-incomplete-empirical\").text(cappedValue.toFixed(3));\n    })\n    .parent_el(\"#heatmap-incomplete-empirical\")\n    .interpolate(false);\n\n  d3.select(\"#heatmap-incomplete-empirical\")\n    .html(\"\")\n    .datum(incomplete_empirical_pv_data)\n    .call(heatmap_incomplete_empirical);\n\n  const svg = d3.select(\"#heatmap-incomplete-empirical\").select(\"svg\");\n\n  const cells = svg.selectAll(\".cell\");\n\n  cells.each(function(d, i) {\n    const cell = d3.select(this);\n    const bbox = this.getBBox();\n\n    d3.select(this.parentNode)\n      .append(\"text\")\n      .attr(\"x\", bbox.x + bbox.width / 2)\n      .attr(\"y\", bbox.y + bbox.height / 2)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"central\")\n      .style(\"font-size\", \"3px\")\n      .style(\"pointer-events\", \"none\")\n      .text((d.prop * 100).toFixed(1) + \"%\");\n  });\n\n  svg.append(\"rect\")\n    .attr(\"x\", passStartParams.x)\n    .attr(\"y\", passStartParams.y)\n    .attr(\"width\", cellParams.width)\n    .attr(\"height\", cellParams.height)\n    .style(\"stroke\", \"blue\")\n    .style(\"fill\", \"none\")\n    .style(\"stroke-width\", \"1px\");\n}\n```\n\n\nI think this grid is fairly intuitive.[^5] Incomplete passes backwards have fairly negative PVs, as those are leading to turnovers probably setting up the opponent for a good scoring opportunity. Incomplete passes forward mostly have neutral PVs, with some spots on the pitch having slightly positive PVs. Notably, a positive PV for an incomplete pass is a non-trivial realization (even if the positive PV is relatively small compared to an analogous successful pass).\n\n[^5]: We observe lots of missingness near the defender's box. Such incomplete passes backwards would be very illogical no matter the game situation, so it's not surprising to see that such passes are not observed in our data set.\n\nSome of the positive PV cells include the area at the top of the 18-yard-box, i.e. [\"zone 14\"](https://www.youtube.com/watch?v=_EFtACGzD7E). You can make the argument that the \"risk\" of losing possession to passes to zone 14 is justified from the potential to take a shot. Further a loss of possession in this area can actually be advantageous, as it leaves the opponent likely in a vulnerable position.\n\n### From Anywhere on the Pitch, To Anywhere on the Pitch\n\nNow lets scale up our pass PV grid to all incomplete passes. As with the dynamic successful pass heatmap, hovering over a cell will show PV associated with unsuccessful passes from that point on the pitch.\n\n\n```{ojs}\n//| include: true\n//| fig-cap: A heatmap showing the average possession value (PV) of historical incomplete pass from the hover spot to all areas on the pitch. The highest and lowest PV values across all end points associated with an incomplete pass from the hover point are shown above the pitch. Black cells represent areas to which unsuccessful passes from the hover spot have never been made.\n{\n  const chart = d3.create(\"div\").style(\"background-color\", \"8f8f8f\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-incomplete-empirical-nested\")\n  title.append(\"p\").html(`min PV: <span id='pv-min-incomplete-empirical-nested'>0</span>, max PV: <span id='pv-max-incomplete-empirical-nested'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-incomplete-empirical-nested\")\n  \n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-incomplete-empirical-nested\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\")\n    .style(\"align-items\", \"center\")\n    .style(\"width\", \"100%\");\n  \n  const legendRange = [\n    1.1 * d3.min(colorScaleIncompleteRange),\n    1.1 * d3.max(colorScaleIncompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n  \n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n  \n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", \"100%\");\n  \n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleIncomplete(d));\n  \n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\")\n    .style(\"width\", `${totalLegendWidth}px`);\n  \n  labelRow.selectAll(\"span\")\n    .data(colorScaleIncompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleIncompleteRange)) {\n        return d + \" <=\";\n      } else if (d === d3.max(colorScaleIncompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\")\n  \n  return chart.node();\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n{  \n  const heatmap_incomplete_empirical_nested = d3_soccer.heatmap(pitch)\n    .colorScale(d3.scaleLinear().domain([-1, 1]).range([\"white\", \"white\"]))\n    .enableInteraction(true)\n    .onSelect((x, y, v) => {\n      const rawMinValue = d3.min(v, d => d.value);\n      const rawMaxValue = d3.max(v, d => d.value);\n      const minValue = Math.max(rawMinValue, -1);\n      const maxValue = Math.min(rawMaxValue, 1);\n  \n      d3.select('#pv-min-incomplete-empirical-nested').text(minValue.toFixed(3));\n      d3.select('#pv-max-incomplete-empirical-nested').text(maxValue.toFixed(3));\n      const cells = d3\n        .select(\"#heatmap-incomplete-empirical-nested\")\n        .selectAll(\"rect.cell\")\n        .data(v)\n  \n      cells.enter()\n        .merge(cells)\n        .attr(\"x\", d => d.x)\n        .attr(\"y\", d => d.y)\n        .attr(\"width\", d => d.width)\n        .attr(\"height\", d => d.height)\n        .style(\"fill\", d => colorScaleIncomplete(+d.value));\n  \n      cells.exit().remove()\n  \n      d3.select(\"#heatmap-incomplete-empirical-nested\")\n        .selectAll(\"rect.cell\")\n        .data(incomplete_empirical_nested_pv_data)\n    })\n    .parent_el(\"#heatmap-incomplete-empirical-nested\")\n    .interpolate(false);\n  \n  d3.select(\"#heatmap-incomplete-empirical-nested\")\n    .html(\"\")\n    .datum(incomplete_empirical_nested_pv_data)\n    .call(heatmap_incomplete_empirical_nested);\n}\n```\n\n\nHovering my mouse over various areas in the middle third of the pitch, I consistently see slightly positive values near the top of the 18-yard box. This is not all that dissimilar from the trend observed with the successful pass pitch, where the passes into the final quarter of the pitch had strong positive PV from basically anywhere. And, like the interactive pitch for completed passes, a 30-yard incomplete pass forward from one's own 18-yard box doesn't have the same PV as a 30-yard incomplete pass forward from the halfline to the opponent's 18-yard box. Not all long incomplete passes are judged equally.\n\n# Conclusion\n\n## Caveats\n\n-   The choice of model surely plays a role in the inference we'll make. Even [atomic VAEP](https://dtai.cs.kuleuven.be/sports/blog/introducing-atomic-spadl:-a-new-way-to-represent-event-stream-data), the cooler younger brother to the baseline VAEP model, may yield different answers due to the way that it treats passes. Atomic VAEP splits passes into two actions--the pass itself and the reception (or lack of).\n\n-   The endpoint of incomplete passes is subject to a fundamental source of noise--interception locations. I've implicitly assumed that unsuccessful passes are intercepted very near to the intended target, but this is not always the case. Interceptions where, for example, the defender blocks a long through ball near where the pass is made, can skew the model training, exaggerating the value of short incomplete passes.\n\n\n```{ojs}\n//| include: false\npitch = d3_soccer.pitch()\n  .height(300)\n  .rotate(false)\n  .showDirOfPlay(true)\n  .shadeMiddleThird(false)\n  .pitchStrokeWidth(0.5)\n  .clip([[0, 0], [105, 68]]);\n```\n\n```{ojs}\n//| include: false\nd3 = require(\"d3@v5\")\n```\n\n```{ojs}\n//| include: false\nd3_soccer = require(\"d3-soccer@0.1.0\")\n```\n\n```{ojs}\n//| label: complete_empirical_prop_data\n//| include: false\ncomplete_empirical_prop_data  = FileAttachment(\"complete_empirical_prop_data.json\").json()\n```\n\n```{ojs}\n//| label: complete_empirical_pv_data\n//| include: false\ncomplete_empirical_pv_data  = FileAttachment(\"complete_empirical_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: complete_empirical_nested_pv_data\n//| include: true\ncomplete_empirical_nested_pv_data = FileAttachment(\"complete_empirical_nested_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: incomplete_empirical_pv_data\n//| include: false\nincomplete_empirical_pv_data  = FileAttachment(\"incomplete_empirical_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: incomplete_empirical_nested_pv_data\n//| include: true\nincomplete_empirical_nested_pv_data = FileAttachment(\"incomplete_empirical_nested_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: colorScaleCompleteRange\n//| include: false\ncolorScaleCompleteRange = [-0.025, 0, 0.025]\n```\n\n```{ojs}\n//| label: colorScaleIncompleteRange\n//| include: false\ncolorScaleIncompleteRange = [-0.025, 0, 0.025]\n```\n\n```{ojs}\n//| label: colorScaleComplete\n//| include: false\ncolorScaleComplete = d3.scaleLinear()\n  .domain(colorScaleCompleteRange)\n  .range([\"#a6611a\", \"white\", \"#018571\"]).clamp(true)\n```\n\n```{ojs}\n//| label: colorScaleIncomplete\n//| include: false\ncolorScaleIncomplete = d3.scaleLinear()\n  .domain(colorScaleIncompleteRange)\n  .range([\"#d01c8b\", \"white\", \"#4dac26\"]).clamp(true)\n```\n\n```{ojs}\n//| label: swatchParams\n//| include: false\nswatchParams = {\n  return {\n    width: 40,\n    height: 20,\n    num: 7\n  }\n}\n```\n\n```{ojs}\n//| label: passStartParams\n//| include: false\npassStartParams = {\n  return {\n    x: 43.75,\n    y: 34\n  }\n}\n```\n\n```{ojs}\n//| label: cellParams\n//| include: false\ncellParams = {\n  return {\n    width: 8.75,\n    height: 8.5\n  }\n}\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}