{
  "hash": "95f64975481b26bef684108f3dee587c",
  "result": {
    "markdown": "---\ntitle: Does completing your passes even matter?\ndescription: Looking at where an incomplete pass can still net you positive ePV.\ndate: 2024-04-01\ndraft: true\ncategories:\n  - r\n  - soccer\nexecute: \n  code-fold: show\n  eval: true\n  include: true\n  echo: false\n---\n\n\n## Introduction\n\nI heard someone recently say something like \"Possession values (PV) models in soccer basically come down to ball progression\". That's an interesting thought, and add a hunch that this isn't too far off.\n\nOne way of getting at that idea is too look at how your PV model treats incomplete passes.\n\n-   Does it say that all long passes are \"good\" (i.e. have \\>0 PV)?\n-   What role does the starting position of the pass play? (i.e. Are balls crossed into the 18-yard box from the wing treated similarly to goal kicks launched into the opponent's box?)\n-   How does PV for an unsuccessful pass compare to a successful one, holding all else equal?\n\nI attempt to answer some of these questions with a VAEP model--an open-source PV model. My model is trained on 2013/14 - 2023/24 English Premier League data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Possession Value (PV) for Passes\n\n### Successful Passes\n\n#### From the Center Spot, To Anywhere on the Pitch\n\nIn the interactive 12x16 pitch below, the red tile illustrates where a hypothetical pass is made, and the colored tiles illustrate the possession value (PV) associated with a successful pass made to that area. Hovering over the tile shows the PV value above the pitch as well.\n\n\n```{ojs}\n//| include: true\n//| code-fold: false\n//| fig-cap: A heatmap showing the possession value (PV) of an average successful pass from roughly the center spot (annotated in blue) to all other spots on the pitch.\n{\n  const chart = d3.create(\"div\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-complete\")\n  title.append(\"p\").html(`PV: <span id='pv-value-complete'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-complete\")\n\n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-complete\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\") // Stack swatches and labels vertically\n    .style(\"align-items\", \"center\") // Center the flex items\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n  \n  const legendRange = [\n    1.1 * d3.min(colorScaleCompleteRange), \n    1.1 * d3.max(colorScaleCompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n  \n  // Calculate the total width for the legend swatches to be used in setting the width of the container\n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n  \n  // Append the swatches as a row\n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of swatches\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n\n  // Append the individual swatches\n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleComplete(d));\n\n  // Append the label row\n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of labels\n    .style(\"width\", `${totalLegendWidth}px`);\n\n  // Append the individual labels under the swatches\n  labelRow.selectAll(\"span\")\n    .data(colorScaleCompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleCompleteRange)) {\n        return \"<= \" + d;\n      } else if (d === d3.max(colorScaleCompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\") // Center the text within its flex item\n\n  return chart.node();\n\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n//| code-fold: false\n{\n  const heatmap_complete = d3_soccer.heatmap(pitch)\n    .colorScale(colorScaleComplete)\n    .enableInteraction(true)\n    .onSelect((x,y,v) => {\n      const cappedValue = Math.min(Math.max(v, -1), 1);\n      d3.select('#pv-value-complete').text(cappedValue.toFixed(3));\n    })\n    .parent_el('#heatmap-complete')\n    .interpolate(false);\n\n  d3.select('#heatmap-complete').html('').datum(complete_pv_data).call(heatmap_complete);\n\n  const svg = d3.select('#heatmap-complete').select('svg');\n\n  svg.append(\"rect\")\n    .attr(\"x\", passStartParams.x)\n    .attr(\"y\", passStartParams.y)\n    .attr(\"width\", tileParams.width)\n    .attr(\"height\", tileParams.height)\n    .style(\"stroke\", \"blue\")\n    .style(\"fill\", \"none\")\n    .style(\"stroke-width\", \"1px\");\n}\n```\n\n\nFIN\n\n#### From Anywhere on the Pitch, To Anywhere on the Pitch\n\nNow, to give the full picture, the interactive pitch below will dynamically update to show PV values associated with a pass starting from the tile that you hover over.\n\n\n```{ojs}\n//| include: true\n//| code-fold: false\n//| fig-cap: A heatmap showing the possession value (PV) of an average successful pass from the hover spot to all other spots on the pitch.\n{\n  const chart = d3.create(\"div\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-complete-nested\")\n  title.append(\"p\").html(`min PV: <span id='pv-min-complete-nested'>0</span>, max PV: <span id='pv-max-complete-nested'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-complete-nested\")\n\n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-complete-nested\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\") // Stack swatches and labels vertically\n    .style(\"align-items\", \"center\") // Center the flex items\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n  \n  const legendRange = [\n    1.1 * d3.min(colorScaleCompleteRange), \n    1.1 * d3.max(colorScaleCompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n  \n  // Calculate the total width for the legend swatches to be used in setting the width of the container\n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n  \n  // Append the swatches as a row\n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of swatches\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n\n  // Append the individual swatches\n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleComplete(d));\n\n  // Append the label row\n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of labels\n    .style(\"width\", `${totalLegendWidth}px`);\n\n  // Append the individual labels under the swatches\n  labelRow.selectAll(\"span\")\n    .data(colorScaleCompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleCompleteRange)) {\n        return \"<= \" + d;\n      } else if (d === d3.max(colorScaleCompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\") // Center the text within its flex item\n\n  return chart.node();\n\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n//| code-fold: false\n{  \n    const heatmap_complete_nested = d3_soccer.heatmap(pitch)\n      .colorScale(d3.scaleLinear().domain([-1, 1]).range([\"white\", \"white\"]))\n      .enableInteraction(true)\n      .onSelect((x,y,v) => {\n        const rawMinValue = d3.min(v, d => d.value);\n        const rawMaxValue = d3.max(v, d => d.value);\n        const minValue = Math.max(rawMaxValue, -1);\n        const maxValue = Math.min(rawMaxValue, 1);\n        \n        d3.select('#pv-min-complete-nested').text(minValue.toFixed(3));\n        d3.select('#pv-max-complete-nested').text(maxValue.toFixed(3));\n        const cells = d3\n          .select(\"#heatmap-complete-nested\")\n          .selectAll(\"rect.cell\")\n          .data(v)\n  \n        cells.enter()\n          .merge(cells) // Merge enter and update selections\n          .attr(\"x\", d => d.x)\n          .attr(\"y\", d => d.y)\n          .attr(\"width\", d => d.width)\n          .attr(\"height\", d => d.height)\n          .style(\"fill\", d => colorScaleComplete(+d.value));\n  \n        cells.exit().remove()\n\n         d3.select(\"#heatmap-complete-nested\").selectAll(\"rect.cell\").data(complete_nested_pv_data)\n      })\n      .parent_el(\"#heatmap-complete-nested\")\n      .interpolate(false);\n\n    d3.select(\"#heatmap-complete-nested\").html(\"\").datum(complete_nested_pv_data).call(heatmap_complete_nested);\n}\n```\n\n\nThere are some oddities if you look close enough, but such is the nature of an ML model.\n\n### Unsuccessful Passes\n\n#### From the Center Spot, To Anywhere on the Pitch\n\nNow, the more interesting side of things--how does the PV heatmap look for incomplete passes? Let's start with an example again, looking at PV for unsuccessful passes from the center spot.\n\n\n```{ojs}\n//| include: true\n//| code-fold: false\n//| fig-cap: A heatmap showing the possession value (PV) of an average unsuccessful pass from roughly the center spot (annotated in blue) to all other spots on the pitch.\n{\n  const chart = d3.create(\"div\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-incomplete\")\n  title.append(\"p\").html(`PV: <span id='pv-value-incomplete'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-incomplete\")\n\n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-incomplete\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\") // Stack swatches and labels vertically\n    .style(\"align-items\", \"center\") // Center the flex items\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n  \n  const legendRange = [\n    1.1 * d3.min(colorScaleIncompleteRange), \n    1.1 * d3.max(colorScaleIncompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n  \n  // Calculate the total width for the legend swatches to be used in setting the width of the container\n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n  \n  // Append the swatches as a row\n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of swatches\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n\n  // Append the individual swatches\n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleIncomplete(d));\n\n  // Append the label row\n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of labels\n    .style(\"width\", `${totalLegendWidth}px`);\n\n  // Append the individual labels under the swatches\n  labelRow.selectAll(\"span\")\n    .data(colorScaleIncompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleIncompleteRange)) {\n        return \"<= \" + d;\n      } else if (d === d3.max(colorScaleIncompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\") // Center the text within its flex item\n\n  return chart.node();\n\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n//| code-fold: false\n{\n  const heatmap_incomplete = d3_soccer.heatmap(pitch)\n    .colorScale(colorScaleIncomplete)\n    .enableInteraction(true)\n    .onSelect((x,y,v) => {\n      const cappedValue = Math.min(Math.max(v, -1), 1);\n      d3.select('#pv-value-incomplete').text(cappedValue.toFixed(3));\n    })\n    .parent_el(\"#heatmap-incomplete\")\n    .interpolate(false);\n\n  d3.select(\"#heatmap-incomplete\").html(\"\").datum(incomplete_pv_data).call(heatmap_incomplete);\n\n  const svg = d3.select(\"#heatmap-incomplete\").select(\"svg\");\n\n  svg.append(\"rect\")\n    .attr(\"x\", passStartParams.x)\n    .attr(\"y\", passStartParams.y)\n    .attr(\"width\", tileParams.width)\n    .attr(\"height\", tileParams.height)\n    .style(\"stroke\", \"blue\")\n    .style(\"fill\", \"none\")\n    .style(\"stroke-width\", \"1px\");\n}\n```\n\n\nI think this grid is actually fairly intuitive. Incomplete passes backwards have very negative PVs, as those are leading to turnovers probably setting up the opponent for a good scoring opportunity. Incomplete passes forward mostly have neutral PVs, with some notable spots on the pitch having non-trivially positive PVs.\n\nSome of those exceptions include the top of the 18-yard-box (i.e. [\"zone 14\"](https://www.youtube.com/watch?v=_EFtACGzD7E)), where a loss of possession can actually be advantageous, as it leaves the opponent likely in a vulnerable position. You could also infer that the \"risk\" of losing possession to passes to zone 14 is justified from the potential to take a shot. The other observable positive PV end-points for passes taken from the center of the pitch are the goal lines on the ends of the 18-yard box. We could deduce that passes to those areas often lead to cutback passes to the front of the goal, which often lead to high-converting shots. So again, the PV model seems to indicate that the \"lost opportunity\" of such a (failed) pass seems worth it. on average.\n\n#### From Anywhere on the Pitch, To Anywhere on the Pitch\n\nNow lets scale up our pass PV grid to all incomplete passes. Hovering over a tile will show PV associated with unsuccessful passes from that point on the pitch.\n\n\n```{ojs}\n//| include: true\n//| code-fold: false\n//| fig-cap: A heatmap showing the possession value (PV) of an average unsuccessful pass from the hover spot to all other spots on the pitch.\n{\n  const chart = d3.create(\"div\")\n  const title = chart.append(\"div\").attr(\"id\", \"heatmap-title-incomplete-nested\")\n  title.append(\"p\").html(`min PV: <span id='pv-min-incomplete-nested'>0</span>, max PV: <span id='pv-max-incomplete-nested'>0</span>`)\n  chart.append(\"div\").attr(\"id\", \"heatmap-incomplete-nested\")\n\n  const legendSwatchContainer = chart.append(\"div\")\n    .attr(\"id\", \"heatmap-legend-incomplete-nested\")\n    .style(\"display\", \"flex\")\n    .style(\"flex-direction\", \"column\") // Stack swatches and labels vertically\n    .style(\"align-items\", \"center\") // Center the flex items\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n  \n  const legendRange = [\n    1.1 * d3.min(colorScaleIncompleteRange), \n    1.1 * d3.max(colorScaleIncompleteRange)\n  ];\n  const stepSize = (legendRange[1] - legendRange[0]) / (swatchParams.num - 1);\n  const legendSwatches = d3.range(legendRange[0], legendRange[1] + stepSize, stepSize);\n  legendSwatches[legendSwatches.length - 1] = legendRange[1];\n  \n  // Calculate the total width for the legend swatches to be used in setting the width of the container\n  const totalLegendWidth = swatchParams.width * swatchParams.num;\n  \n  // Append the swatches as a row\n  const swatchRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of swatches\n    .style(\"width\", \"100%\"); // Take up the full width to center the content\n\n  // Append the individual swatches\n  swatchRow.selectAll(\"div\")\n    .data(legendSwatches)\n    .enter()\n    .append(\"div\")\n    .style(\"width\", `${swatchParams.width}px`)\n    .style(\"height\", `${swatchParams.height}px`)\n    .style(\"background-color\", d => colorScaleIncomplete(d));\n\n  // Append the label row\n  const labelRow = legendSwatchContainer.append(\"div\")\n    .style(\"display\", \"flex\")\n    .style(\"justify-content\", \"center\") // Center the row of labels\n    .style(\"width\", `${totalLegendWidth}px`);\n\n  // Append the individual labels under the swatches\n  labelRow.selectAll(\"span\")\n    .data(colorScaleIncompleteRange)\n    .enter()\n    .append(\"span\")\n    .text(d => {\n      if (d === d3.min(colorScaleIncompleteRange)) {\n        return \"<= \" + d;\n      } else if (d === d3.max(colorScaleIncompleteRange)) {\n        return \">= \" + d;\n      }\n      return d;\n    })\n    .style(\"flex\", d => d === 0 ? \"1\" : null)\n    .style(\"text-align\", \"center\") // Center the text within its flex item\n\n  return chart.node();\n\n}\n```\n\n```{ojs}\n//| echo: false\n//| output: false\n//| code-fold: false\n{  \n    const heatmap_incomplete_nested = d3_soccer.heatmap(pitch)\n      .colorScale(d3.scaleLinear().domain([-1, 1]).range([\"white\", \"white\"]))\n      .enableInteraction(true)\n      .onSelect((x,y,v) => {\n        const rawMinValue = d3.min(v, d => d.value);\n        const rawMaxValue = d3.max(v, d => d.value);\n        const minValue = Math.max(rawMaxValue, -1);\n        const maxValue = Math.min(rawMaxValue, 1);\n        \n        d3.select('#pv-min-incomplete-nested').text(minValue.toFixed(3));\n        d3.select('#pv-max-incomplete-nested').text(maxValue.toFixed(3));\n        const cells = d3\n          .select(\"#heatmap-incomplete-nested\")\n          .selectAll(\"rect.cell\")\n          .data(v)\n  \n        cells.enter()\n          .merge(cells) // Merge enter and update selections\n          .attr(\"x\", d => d.x)\n          .attr(\"y\", d => d.y)\n          .attr(\"width\", d => d.width)\n          .attr(\"height\", d => d.height)\n          .style(\"fill\", d => colorScaleIncomplete(+d.value));\n  \n        cells.exit().remove()\n\n         d3.select(\"#heatmap-incomplete-nested\").selectAll(\"rect.cell\").data(incomplete_nested_pv_data)\n      })\n      .parent_el(\"#heatmap-incomplete-nested\")\n      .interpolate(false);\n\n    d3.select(\"#heatmap-incomplete-nested\").html(\"\").datum(incomplete_nested_pv_data).call(heatmap_incomplete_nested);\n}\n```\n\n\n## Conclusion\n\nI'll note that the choice of model surely plays a role in the inference we'll make. Even atomic VAEP, which splits passes into two actions--the pass itself and the reception (or lack of)--may yield different answers.\n\n\n```{ojs}\n//| include: false\npitch = d3_soccer.pitch()\n  .height(300)\n  .rotate(false)\n  .showDirOfPlay(true)\n  .shadeMiddleThird(false)\n  .pitchStrokeWidth(0.5)\n  .clip([[0, 0], [105, 68]]);\n```\n\n```{ojs}\n//| include: false\nd3 = require(\"d3@v5\")\n```\n\n```{ojs}\n//| include: false\nd3_soccer = require(\"d3-soccer@0.1.0\")\n```\n\n```{ojs}\n//| label: complete_pv_data\n//| include: false\ncomplete_pv_data  = FileAttachment(\"complete_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: incomplete_pv_data\n//| include: false\nincomplete_pv_data = FileAttachment(\"incomplete_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: complete_nested_pv_data\n//| include: false\ncomplete_nested_pv_data  = FileAttachment(\"complete_nested_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: incomplete_nested_pv_data\n//| include: false\nincomplete_nested_pv_data = FileAttachment(\"incomplete_nested_pv_data.json\").json()\n```\n\n```{ojs}\n//| label: colorScaleCompleteRange\n//| include: false\ncolorScaleCompleteRange = [-0.025, 0, 0.025]\n```\n\n```{ojs}\n//| label: colorScaleIncompleteRange\n//| include: false\ncolorScaleIncompleteRange = [-0.025, 0, 0.025]\n```\n\n```{ojs}\n//| label: colorScaleComplete\n//| include: false\ncolorScaleComplete = d3.scaleLinear()\n  .domain(colorScaleCompleteRange)\n  .range([\"#a6611a\", \"white\", \"#018571\"]).clamp(true)\n```\n\n```{ojs}\n//| label: colorScaleIncomplete\n//| include: false\ncolorScaleIncomplete = d3.scaleLinear()\n  .domain(colorScaleIncompleteRange)\n  .range([\"#d01c8b\", \"white\", \"#4dac26\"]).clamp(true)\n```\n\n```{ojs}\n//| label: swatchParams\n//| include: false\nswatchParams = {\n  return {\n    width: 40,\n    height: 20,\n    num: 7\n  }\n}\n```\n\n```{ojs}\n//| label: passStartParams\n//| include: false\npassStartParams = {\n  return {\n    x: 45.9375,\n    y: 28.33333\n  }\n}\n```\n\n```{ojs}\n//| label: tileParams\n//| include: false\ntileParams = {\n  return {\n    width: 6.5625,\n    height: 5.666667\n  }\n}\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}