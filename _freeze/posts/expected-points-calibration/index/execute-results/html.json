{
  "hash": "53edd98ff3478ae2451f68f671707aff",
  "result": {
    "markdown": "---\ntitle: Improving Expected Points\ndescription: Using Beta calibration to improve the descriptive accuracy of expected points in soccer\ndate: 2023-09-10\ndraft: true\ncategories:\n  - r\n  - soccer\nimage: footedness_calibration.png\nexecute: \n  code-fold: false\n  eval: false\n  include: true\n  echo: true\n---\n\n\n## Introduction\n\nThis blog post demonstrates how to adjust [expected goals (xG)](https://theanalyst.com/na/2021/07/what-are-expected-goals-xg/) to enhance the accuracy of predicting [match points](https://en.wikipedia.org/wiki/Three_points_for_a_win) for soccer (football) teams. This is achieved through a technique called calibration (or [\"remediation\"](https://www.tidymodels.org/learn/models/calibration/#remediation)), which improves the reliability of [**expected points (xPts)**](https://www.bettingodds.com/news/what-are-expected-points-xp-football-betting) relation to the teams' real performance.\n\nIf you don't care at all about what \"expected points\" are or simply just want to see how to do such a model adjustment with R, feel free to skip past the \"Introduction\" section.\n\n### Expected Points\n\nIn [a prior post](/posts/opta-xg-model-calibration/), I showed how to calculate **expected points (xPts)** from expected goals (xG) for the beautiful game of soccer (football). What is xPts? Well, to quote myself:\n\n> \\[xPts\\] a number between 0 and 3 assigned to each team in a match that we estimate from the xG of each shot in the match. Teams that accumulate more xG than their opponents in the match are more likely to have xPts closer to 3, i.e. the points awarded for a win... xPts is convenient for translating a team's xG (relative to it's opponents) to the team's expected placement in the standings.\n\nOne thing that is not traditionally accounted for with xPts: [**game state**](https://theathletic.com/2730755/2021/07/28/the-athletics-football-analytics-glossary-explaining-xg-ppda-field-tilt-and-how-to-use-them/), i.e. whether \"the team is in a losing, drawing or winning position when they are performing certain actions\". To account for this, we need to make xG \"aware\" of the game state.\n\nOne way to do that would be to add game state as an input feature to the xG model. However:\n\n1.  I'm not the creator of the xG model that I'll be using, so I can't actually do that.\n2.  Further, and more importantly, I don't think this is a good idea, based on conceptual integrity.\n\nOn the latter point--traditional xG models are supposed to be agnostic to everything but the actual attributes of the shot. Sure, we could improve an xG model by having a dummy variable for whether the shot taker is Lionel Messi, but that goes against the spirit of the xG model.[^1]\n\n[^1]: This isn't to discredit [research](https://statsbomb.com/wp-content/uploads/2022/09/Tahmeed-Tureen-and-Sigrid-Olthof-%E2%80%93-Estimated-Player-Impact-EPI-Quantifying-The-Effects-Of-Individual-Players-On-Football-Actions-Using-Hierarchical-Statistical-Models.pdf) conducted where player effects are modeled as part of xG---I actually really like doing that kind of thing when trying to tease out estimates of player skill. However, for the sole purpose of quantifying the innate quality of a shot, adding inputs that aren't directly related to the attributes of a shot, such as game state, feel unjustified, even if they would improve model performance.\n\nWith that being said, when we're applying xG for a separate task, such as for calculating xPts, accounting for game state is fair game. One way to do so is via a second model that \"calibrates\" the output of the original model. In our case, we would want to calibrate the output of the xG model against the actual goal conversion rate, accounting for game state.[^2]\n\n[^2]: You could also calibrate the output of a model to achieve marginal gains when there are no external factors you want to account for and achieve marginal gains.)\n\nSo let's dive in.\n\n## Analysis\n\nWe'll be using data from [FBref](https://fbref.com/), which gets its xG from [Opta](https://www.statsperform.com/opta/). We'll limit the scope to the 2017/18 through 2022/23 seasons for the English Premier League. This post isn't about data collection, so I'll skip those details.\n\nHere's a glance at the data frame I'm working with.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(qs)\nlibrary(purrr)\nlibrary(probably) ## 0.1.0.9008\npackageVersion('probably') \n\nlibrary(ggplot2)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(ggtext)\nlibrary(ragg)\nlibrary(htmltools)\n\nmatch_results <- qs::qread(file.path(PROJ_DIR, 'match_results.qs'))\nraw_shots <- qs::qread(file.path(PROJ_DIR, 'shots.qs')) |> \n  dplyr::filter(\n    pov == 'primary',\n    !is_own_goal\n  )\n\nshots <- raw_shots |> \n  dplyr::inner_join(\n    match_results |> \n      dplyr::distinct(\n        match_id,\n        home_team,\n        away_team\n      ),\n    by = dplyr::join_by(match_id)\n  ) |> \n  dplyr::transmute(\n    match_id,\n    season,\n    date,\n    home_team,\n    away_team,\n    team,\n    player,\n    shot_id,\n    is_penalty,\n    is_goal,\n    .pred_yes = xg,\n    .pred_no = 1 - xg,\n    game_state = cut(\n      game_state,\n      breaks = c(-Inf, -1, 0, Inf), \n      labels = c('trailing', 'neutral', 'leading')\n    )\n  ) |> \n  dplyr::group_by(match_id) |> \n  dplyr::arrange(shot_id, .by_group = TRUE) |> \n  dplyr::mutate(\n    pre_shot_game_state = dplyr::lag(game_state, default = 'neutral')\n  ) |> \n  dplyr::ungroup()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(dplyr)\nshots |> \n  dplyr::select(\n    shot_id,\n    team,\n    player,\n    is_goal,\n    pre_shot_game_state,\n    .pred_yes, ## xg\n    .pred_no   ## 1 - xg\n  )\n#> # A tibble: 56,872 × 7\n#>    shot_id          team        player is_goal pre_shot_game_state .pred_yes .pred_no\n#>    <chr>       <chr>       <chr>  <fct>   <fct>                   <dbl>    <dbl>\n#>  1 0014076a-01 Arsenal     Henri… no      neutral                  0.03     0.97\n#>  2 0014076a-02 Arsenal     Henri… no      neutral                  0.06     0.94\n#>  3 0014076a-03 West Ham U… Marko… no      neutral                  0.08     0.92\n#>  4 0014076a-04 West Ham U… Marko… no      neutral                  0.03     0.97\n#>  5 0014076a-05 West Ham U… Marko… yes     neutral                  0.05     0.95\n#>  6 0014076a-06 Arsenal     Aaron… no      leading                  0.11     0.89\n#>  7 0014076a-07 Arsenal     Nacho… yes     trailing                 0.6      0.4 \n#>  8 0014076a-08 West Ham U… Micha… no      neutral                  0.07     0.93\n#>  9 0014076a-09 West Ham U… Felip… no      neutral                  0.07     0.93\n#> 10 0014076a-10 Arsenal     Shkod… no      neutral                  0.02     0.98\n#> # ℹ 56,862 more rows\n```\n:::\n\n\nLet's start by taking a look at the calibration of the Opta xG model, splitting by game state. (Note that this uses `probably::cal_plot_breaks()`.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(probably)\n# packageVersion('probably') ## 0.1.0.9008\n\nlibrary(ggplot2)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(ggtext)\nlibrary(htmltools)\n\nCAL_N_BREAKS <- 20\nCAL_CONF_LEVEL <- 0.9\n\nTAG_LABEL <- htmltools::tagList(\n  htmltools::tags$span(htmltools::HTML(enc2utf8(\"&#xf099;\")), style = 'font-family:fb'),\n  htmltools::tags$span(\"@TonyElHabr\"),\n)\nSUBTITLE_LABEL <- 'English Premier League, 2017/18 - 2022/23'\nPLOT_RESOLUTION <- 300\nWHITISH_FOREGROUND_COLOR <- 'white'\nCOMPLEMENTARY_FOREGROUND_COLOR <- '#f1f1f1'\nBLACKISH_BACKGROUND_COLOR <- '#1c1c1c'\nCOMPLEMENTARY_BACKGROUND_COLOR <- '#4d4d4d'\nFONT <- 'Titillium Web'\nsysfonts::font_add_google(FONT, FONT)\n## https://github.com/tashapiro/tanya-data-viz/blob/main/chatgpt-lensa/chatgpt-lensa.R for twitter logo\nsysfonts::font_add('fb', 'Font Awesome 6 Brands-Regular-400.otf')\nshowtext::showtext_auto()\nshowtext::showtext_opts(dpi = PLOT_RESOLUTION)\n\nggplot2::theme_set(ggplot2::theme_minimal())\nggplot2::theme_update(\n  text = ggplot2::element_text(family = FONT),\n  title = ggplot2::element_text(size = 20, color = WHITISH_FOREGROUND_COLOR),\n  plot.title = ggplot2::element_text(face = 'bold', size = 20, color = WHITISH_FOREGROUND_COLOR),\n  plot.title.position = 'plot',\n  plot.subtitle = ggplot2::element_text(size = 16, color = COMPLEMENTARY_FOREGROUND_COLOR),\n  axis.text = ggplot2::element_text(color = WHITISH_FOREGROUND_COLOR, size = 14),\n  axis.title = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),\n  axis.line = ggplot2::element_blank(),\n  strip.text = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0),\n  panel.grid.major = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),\n  panel.grid.minor = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),\n  panel.grid.minor.x = ggplot2::element_blank(),\n  panel.grid.minor.y = ggplot2::element_blank(),\n  plot.margin = ggplot2::margin(10, 20, 10, 20),\n  plot.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR),\n  plot.caption = ggtext::element_markdown(color = WHITISH_FOREGROUND_COLOR, hjust = 0, size = 10, face = 'plain'),\n  plot.caption.position = 'plot',\n  plot.tag = ggtext::element_markdown(size = 12, color = WHITISH_FOREGROUND_COLOR, hjust = 1),\n  plot.tag.position = c(0.99, 0.01),\n  panel.spacing.x = grid::unit(2, 'lines'),\n  panel.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR)\n)\nggplot2::update_geom_defaults('text', list(color = WHITISH_FOREGROUND_COLOR, size = 12 / .pt))\nggplot2::update_geom_defaults('point', list(color = WHITISH_FOREGROUND_COLOR))\n\nplot_and_save_calibration <- function(\n    df,\n    .by,\n    size = 7,\n    width = size, \n    height = size, \n    title = NULL,\n    caption = NULL,\n    filename = tempfile(),\n    extra_layers\n) {\n  \n  group_cols <- rlang::ensyms(.by)\n  \n  p <- df |> \n    ggplot2::ggplot() +\n    ggplot2::aes(x = predicted_midpoint, y = event_rate) +\n    ggplot2::geom_abline(color = WHITISH_FOREGROUND_COLOR, linetype = 2) +\n    ggplot2::geom_ribbon(\n      fill = '#999999',\n      alpha = 0.5,\n      ggplot2::aes(ymin = lower, ymax = upper)\n    ) +\n    ggplot2::geom_line(color = WHITISH_FOREGROUND_COLOR) +\n    ggplot2::geom_point(\n      color = WHITISH_FOREGROUND_COLOR,\n      ggplot2::aes(size = total),\n      show.legend = FALSE\n    ) +\n    ggplot2::coord_cartesian(\n      xlim = c(0, 1),\n      ylim = c(0, 1)\n    ) +\n    ggplot2::labs(\n      title = paste0(c('Opta xG calibration', title), collapse = ' by '),\n      subtitle = SUBTITLE_LABEL,\n      y = 'Actual goal rate',\n      x = 'Expected goals (xG)',\n      caption = paste0(c('**Data**: Opta via fbref.<br/>Point size is proportional to number of observations.', caption), collapse = '\\n'),\n      tag = TAG_LABEL\n    ) + \n    ggplot2::theme(\n      panel.grid.major = ggplot2::element_blank(),\n      panel.background = ggplot2::element_rect(color = WHITISH_FOREGROUND_COLOR)\n    ) + \n    ggplot2::facet_wrap(ggplot2::vars(!!!group_cols))\n  \n  if (isFALSE(missing(extra_layers))) {\n    p <- p + extra_layers\n  }\n  \n  ggplot2::ggsave(\n    p,\n    filename = file.path(PROJ_DIR, sprintf('%s_calibration.png', filename)),\n    width = width,\n    height = height\n  )\n  invisible(p)\n}\n\nxg_cal_plot_breaks <- purrr::partial(\n  probably::cal_plot_breaks,\n  num_breaks = CAL_N_BREAKS,\n  conf_level = CAL_CONF_LEVEL,\n  event_level = 'second'\n)\n\nextra_xg_cal_plot_layers <- list(\n  ggplot2::geom_segment(\n    data = data.frame(\n      x = 0.45,\n      xend = 0.35,\n      y = 0.6,\n      yend = 0.7,\n      pre_shot_game_state = 'leading'\n    ),\n    arrow = grid::arrow(length = grid::unit(6, 'pt'), type = 'closed'),\n    ggplot2::aes(\n      x = x,\n      xend = xend,\n      y = y,\n      yend = yend\n    ),\n    linewidth = 1,\n    color = '#009ffd'\n  ),\n  ggplot2::geom_segment(\n    data = data.frame(\n      x = 0.55,\n      xend = 0.65,\n      y = 0.4,\n      yend = 0.3,\n      pre_shot_game_state = 'leading'\n    ),\n    arrow = grid::arrow(length = grid::unit(6, 'pt'), type = 'closed'),\n    ggplot2::aes(\n      x = x,\n      xend = xend,\n      y = y,\n      yend = yend\n    ),\n    linewidth = 1,\n    color = '#ffa400'\n  ),\n  ggtext::geom_richtext(\n    data = data.frame(\n      x = 0.65,\n      y = 0.8,\n      label = 'Model *under-predicts*',\n      pre_shot_game_state = 'leading'\n    ),\n    fill = NA, label.color = NA,\n    label.padding = grid::unit(rep(0, 1), 'pt'),\n    color = '#009ffd',\n    family = FONT,\n    hjust = 1,\n    vjust = 0.5,\n    size = 12 / ggplot2::.pt,\n    ggplot2::aes(\n      x = x,\n      y = y,\n      label = label\n    )\n  ),\n  ggtext::geom_richtext(\n    data = data.frame(\n      x = 0.35,\n      y = 0.2,\n      label = 'Model *over-predicts*',\n      pre_shot_game_state = 'leading'\n    ),\n    fill = NA, label.color = NA,\n    label.padding = grid::unit(rep(0, 1), 'pt'),\n    color = '#ffa400',\n    family = FONT,\n    hjust = 0,\n    vjust = 0.5,\n    size = 12 / ggplot2::.pt,\n    ggplot2::aes(\n      x = x,\n      y = y,\n      label = label\n    )\n  )\n)\n\ncalib_game_state <- shots |> \n  xg_cal_plot_breaks(\n    truth = is_goal,\n    estimate = .pred_yes,\n    .by = pre_shot_game_state\n  ) |> \n  purrr::pluck('data')\n\nplot_and_save_calibration(\n  calib_game_state,\n  width = 9,\n  height = 9 / 2,\n  extra_layers = extra_xg_cal_plot_layers,\n  .by = pre_shot_game_state,\n  title = 'game state',\n  filename = 'no_pre_shot_game_state_xg'\n)\n```\n:::\n\n\n![](no_pre_shot_game_state_xg_calibration.png)\n\n## TODO\n\n[There is evidence](https://twitter.com/Torvaney/status/1623316194936725506) that the current score of a match effects shooting rate, but it's not so clear that it has [an effect on conversion probability](https://kwiatkowski.io/rethinking-shots).\n\n## Conclustion\n\n*\"Why should accounting for game state create a more accurate set of xPts? Doesn't xG already directly capture the fact that teams trailing in a match may be taking more, lower quality shots?\"* Well, there are at least two confounding factors that immediately come to mind:\n\n1.  Players on the trailing team may be taking more off-balance or rushed shots that they would not otherwise take. Traditional xG model, which do not account for body pose or footedness, do not capture this kind of \"desperateness\".\n2.  Players on teams that fall behind their opponents tend to have less finishing skill. Lower finishing skill generally manifests in worse goal conversion rates. Thust, the xG of shots taken by such players may tend to overrate their actual number of goals scored.\n\nA picture is worth a thousand words.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}