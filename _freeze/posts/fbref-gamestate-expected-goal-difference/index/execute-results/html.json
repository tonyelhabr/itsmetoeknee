{
  "hash": "35680bd9785e877f37cde875a4c5de0f",
  "result": {
    "markdown": "---\ntitle: Game state with FBref data\ndescription: Calculating expected goal difference (xGD) with respect to game state, using FBref data.\ndate: 2023-10-25\ncategories:\n  - r\n  - soccer\nimage: 2023-mls-xgd-p90.png\nexecute: \n  code-fold: true\n  eval: false\n  include: true\n  echo: true\n---\n\n\n## Introduction\n\nSoccer, a game defined by its discrete, low-scoring nature, thrives on the dynamics of the [\"game state\"](https://statsbomb.com/articles/soccer/game-states-and-loss-aversion/). Whether a team is leading, trailing, or level with their opponent at a specific moment can wield a profound influence on their tactical choices and overall approach. It's the kind of context that can shed new light on key statistics like shots and [expected goals (xG)](https://theanalyst.com/na/2021/07/what-are-expected-goals-xg/).\n\nConsider this scenario: a team enters a match as heavy favorites, and they gain a substantial lead early on. As they switch to a more defensive strategy--\"loss aversion\"--the number of shots taken and xG accumulated may appear unexpectedly low, potentially raising eyebrows. But when you factor in that this favored team spent more than half the game with a comfortable 3-goal lead, those seemingly \"poor\" statistics suddenly take on a different meaning.\n\nThe idea seems straightforward, right? Yet, game state analysis remains somewhat underutilized in the world of soccer analytics. Why is that? Well, it's not without its challenges. Contextualizing numbers according to game state can introduce biases, leading us to over-attribute outcomes to tactical choices. Moreover, the calculations involved can be far from trivial.\n\nSo that's what this post is for. I'll walk through how to calculate expected goals difference (xGD)[^1]--the difference between your team's expected goals and your opponent's--with respect to the game state, using data from [FBref](https://fbref.com/).\n\n[^1]: I like xGD because it captures a lot of information about how your team is playing relative to your opponent. Your team could be putting up a lot of shots, each with a decent amount of xG (i.e. \"shot quality\"), but if you're conceding even more shots than you've taken and/or the quality of those shots are better than yours, then you're really not performing all that well. This would be reflected with a negative xGD. Respected analysts like [Michael Caley](https://twitter.com/MC_of_A) also seem to like [using xGD](https://twitter.com/MC_of_A/status/1716474802259574848) for diagnosing performance.\n\n## Data pull\n\nThe 2023 Major League Soccer (MLS) regular season just ended, and I'm interested to see what we might learn about the teams who qualified for playoffs. So, naturally, I've chosen to focus on this past MLS season for our game state calculations.\n\nTo begin, we pull raw FBref data from pre-saved `{worldfootballR}` release data, starting with match shots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## data scrape\nlibrary(worldfootballR)  ## version: 0.6.4.9\n\n## data manipulation\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(tidyr)\n\nCOUNTRY <- 'USA'\nGENDER <- 'M'\nTIER <- '1st'\nSEASON_END_YEAR <- 2023\n\nraw_shots <- worldfootballR::load_fb_match_shooting(\n  country = COUNTRY,\n  gender = GENDER,\n  tier = TIER,\n  season_end_year = SEASON_END_YEAR\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(raw_shots)\n#> Rows: 15,277\n#> Columns: 23\n#> $ MatchURL         <chr> \"https://fbref.com/en/matches/48a684ed/Nashville-S…\n#> $ Date             <chr> \"2023-02-25\", \"2023-02-25\", \"2023-02-25\", \"2023-02…\n#> $ Squad            <chr> \"Nashville\", \"Nashville\", \"Nashville\", \"Nashville\"…\n#> $ Home_Away        <chr> \"Home\", \"Home\", \"Home\", \"Home\", \"Home\", \"Home\", \"H…\n#> $ Match_Half       <dbl> 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2,…\n#> $ Minute           <chr> \"6\", \"13\", \"31\", \"34\", \"45+1\", \"51\", \"73\", \"80\", \"…\n#> $ Player           <chr> \"Jacob Shaffelburg\", \"Sean Davis\", \"Teal Bunbury\",…\n#> $ Player_Href      <chr> \"/en/players/339a2561/Jacob-Shaffelburg\", \"/en/pla…\n#> $ xG               <chr> \"0.39\", \"0.09\", \"0.03\", \"0.25\", \"0.04\", \"0.02\", \"0…\n#> $ PSxG             <chr> \"0.47\", \"\", \"0.06\", \"0.74\", \"\", \"\", \"\", \"0.96\", \"\"…\n#> $ Outcome          <chr> \"Saved\", \"Off Target\", \"Saved\", \"Goal\", \"Off Targe…\n#> $ Distance         <chr> \"16\", \"18\", \"29\", \"8\", \"17\", \"25\", \"28\", \"11\", \"22…\n#> $ `Body Part`      <chr> \"Right Foot\", \"Left Foot\", \"Right Foot\", \"Right Fo…\n#> $ Notes            <chr> \"\", \"Volley\", \"Deflected\", \"Volley\", \"\", \"\", \"\", \"…\n#> $ Player_SCA_1     <chr> \"Randall Leal\", \"Aníbal Godoy\", \"Jacob Shaffelburg…\n#> $ Event_SCA_1      <chr> \"Pass (Live)\", \"Pass (Live)\", \"Pass (Live)\", \"Pass…\n#> $ Player_SCA_2     <chr> \"Walker Zimmerman\", \"Jack Maher\", \"Joe Willis\", \"T…\n#> $ Event_SCA_2      <chr> \"Pass (Live)\", \"Pass (Live)\", \"Pass (Live)\", \"Foul…\n#> $ Competition_Name <chr> \"Major League Soccer\", \"Major League Soccer\", \"Maj…\n#> $ Gender           <chr> \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", …\n#> $ Country          <chr> \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"…\n#> $ Tier             <chr> \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"…\n#> $ Season_End_Year  <int> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, 20…\n```\n:::\n\n\nGiven a match URL like [this](https://fbref.com/en/matches/82503f4e/Atlanta-United-Inter-Miami-September-16-2023-Major-League-Soccer), `worldfootballR::load_fb_match_shooting()` provides data from the \"Shots\" table on the page.\n\n![](match-shots.png)\n\nWhile it might seem like the shots table is all we'd need to calculate expected goal difference (xGD), FBref's match shot log table doesn't include own goals. Nonetheless, we can use `worldfootballR::load_fb_match_summary()` to extract timestamps for own goals from the \"Match Summary\" timeline.\n\n![](match-summary.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_match_summaries <- worldfootballR::load_fb_match_summary(\n  country = COUNTRY,\n  gender = GENDER,\n  tier = TIER,\n  season_end_year = SEASON_END_YEAR\n)\ndplyr::glimpse(raw_match_summaries)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(raw_match_summaries)\n#> Rows: 9,565\n#> Columns: 33\n#> $ MatchURL          <chr> \"https://fbref.com/en/matches/48a684ed/Nashville-…\n#> $ League            <chr> \"Major League Soccer\", \"Major League Soccer\", \"Ma…\n#> $ Match_Date        <chr> \"2023-02-25\", \"2023-02-25\", \"2023-02-25\", \"2023-0…\n#> $ Matchweek         <chr> \"Major League Soccer (Regular Season)\", \"Major Le…\n#> $ Home_Team         <chr> \"Nashville SC\", \"Nashville SC\", \"Nashville SC\", \"…\n#> $ Home_Formation    <chr> \"4-2-3-1\", \"4-2-3-1\", \"4-2-3-1\", \"4-2-3-1\", \"4-2-…\n#> $ Home_Score        <dbl> 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2…\n#> $ Home_xG           <dbl> 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3,…\n#> $ Home_Goals        <chr> \"Walker Zimmerman · 34&rsquor; Jacob Shaffelburg …\n#> $ Home_Yellow_Cards <chr> \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\",…\n#> $ Home_Red_Cards    <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\",…\n#> $ Away_Team         <chr> \"New York City FC\", \"New York City FC\", \"New York…\n#> $ Away_Formation    <chr> \"4-2-3-1\", \"4-2-3-1\", \"4-2-3-1\", \"4-2-3-1\", \"4-2-…\n#> $ Away_Score        <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1…\n#> $ Away_xG           <dbl> 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4,…\n#> $ Away_Goals        <chr> \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"…\n#> $ Away_Yellow_Cards <chr> \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\", \"4\",…\n#> $ Away_Red_Cards    <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\",…\n#> $ Game_URL          <chr> \"https://fbref.com/en/matches/48a684ed/Nashville-…\n#> $ Team              <chr> \"New York City FC\", \"Nashville SC\", \"Nashville SC…\n#> $ Home_Away         <chr> \"Away\", \"Home\", \"Home\", \"Away\", \"Away\", \"Home\", \"…\n#> $ Event_Time        <dbl> 28, 34, 58, 62, 70, 72, 74, 75, 80, 82, 82, 83, 9…\n#> $ Is_Pens           <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, …\n#> $ Event_Half        <dbl> 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2…\n#> $ Event_Type        <chr> \"Yellow Card\", \"Goal\", \"Yellow Card\", \"Yellow Car…\n#> $ Event_Players     <chr> \"Braian Cufré\", \"Walker Zimmerman Assist: Fafà Pi…\n#> $ Score_Progression <chr> \"0:0\", \"1:0\", \"1:0\", \"1:0\", \"1:0\", \"1:0\", \"1:0\", …\n#> $ Penalty_Number    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ Competition_Name  <chr> \"Major League Soccer\", \"Major League Soccer\", \"Ma…\n#> $ Gender            <chr> \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\",…\n#> $ Country           <chr> \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", \"USA\", …\n#> $ Tier              <chr> \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", …\n#> $ Season_End_Year   <int> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2…\n```\n:::\n\n\n## Data wrangling\n\nNow we start to clean up the raw data. Starting with the match summary data, we:\n\n1.  Create a `match_id` field, to make it easy to join this data set with the shots data set.\n2.  Clean up the time fields, `minutes` and `minutes_added`.\n3.  Rename existing columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Extract the from \"47880eb7\" from \"https://fbref.com/en/matches/47880eb7/Liverpool-Manchester-City-November-10-2019-Premier-League\"\nextract_fbref_match_id <- function(match_url) {\n  basename(dirname(match_url))\n}\n\nmatch_summaries <- raw_match_summaries |> \n  dplyr::group_by(MatchURL) |> \n  dplyr::mutate(\n    match_summary_rn = dplyr::row_number(dplyr::desc(Event_Time)),\n    match_has_no_penalties = all(Event_Type != 'Penalty')\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::mutate(\n    match_has_no_goals = Away_Score == 0 & Home_Score == 0\n  ) |> \n  ## Drop non-shot events, e.g. card and substitution events. \n  ##   Always keep the first timeline event, so that we're not accidentally dropping matches.\n  dplyr::filter(\n    Event_Type %in% c('Goal', 'Own Goal', 'Penalty') | \n      ## don't drop games with no goals\n      (match_has_no_goals & match_has_no_penalties & match_summary_rn == 1)\n  ) |> \n  dplyr::transmute(\n    match_id = extract_fbref_match_id(MatchURL),\n    season = Season_End_Year,\n    gender = Gender,\n    tier = Tier,\n    date = lubridate::ymd(Match_Date),\n    home_team = Home_Team ,\n    away_team = Away_Team,\n    period = as.integer(Event_Half),\n    ## ensure that minutes always has a value\n    minutes = dplyr::case_when(\n      period == 1L & Event_Time > 45L ~ 45L, \n      period == 2L & Event_Time > 90L ~ 90L,\n      .default = Event_Time\n    ) |> as.integer(),\n    minutes_added = dplyr::case_when(\n      period == 1L & Event_Time > 45 ~ Event_Time - 45L, \n      period == 2L & Event_Time > 90 ~ Event_Time - 90L,\n      .default = NA_integer_\n    ),\n    home_g = as.integer(gsub('[:].*$', '', Score_Progression)), ## after event\n    away_g = as.integer(gsub('^.*[:]', '', Score_Progression)),\n    is_own_goal = Event_Type == 'Own Goal',\n    team = Team,\n    player = Event_Players\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(match_summaries)\n#> Rows: 1,752\n#> Columns: 15\n#> $ match_id      <chr> \"48a684ed\", \"48a684ed\", \"1861e533\", \"1861e533\", \"1861…\n#> $ season        <int> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023,…\n#> $ gender        <chr> \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\", \"M\"…\n#> $ tier          <chr> \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st\", \"1st…\n#> $ date          <date> 2023-02-25, 2023-02-25, 2023-02-25, 2023-02-25, 2023…\n#> $ home_team     <chr> \"Nashville SC\", \"Nashville SC\", \"FC Cincinnati\", \"FC …\n#> $ away_team     <chr> \"New York City FC\", \"New York City FC\", \"Houston Dyna…\n#> $ period        <int> 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1,…\n#> $ minutes       <int> 34, 80, 19, 45, 48, 48, 12, 39, 90, 90, 28, 45, 52, 7…\n#> $ minutes_added <dbl> NA, NA, NA, 2, NA, NA, NA, NA, 3, 9, NA, 3, NA, NA, N…\n#> $ home_g        <int> 1, 2, 1, 1, 2, 0, 0, 0, 1, 2, 0, 1, 2, 3, 4, 1, 0, 1,…\n#> $ away_g        <int> 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,…\n#> $ is_own_goal   <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS…\n#> $ team          <chr> \"Nashville SC\", \"Nashville SC\", \"FC Cincinnati\", \"Hou…\n#> $ player        <chr> \"Walker Zimmerman Assist: Fafà Picault\", \"Jacob Shaff…\n```\n:::\n\n\nNext, we start to clean up the `shots` data frame. The data wrangling is similar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshots <- raw_shots |> \n  dplyr::transmute(\n    match_id = extract_fbref_match_id(MatchURL),\n    period = as.integer(Match_Half),\n    ## convert \"45+2\" to \"45\"\n    minutes = ifelse(\n      grepl('[+]', Minute),\n      as.integer(gsub('(^[0-9]+)[+]([0-9]+$)', '\\\\1', Minute)), \n      as.integer(Minute)\n    ),\n    ## convert \"45+2\" to \"2\"\n    minutes_added = ifelse(\n      grepl('[+]', Minute), \n      as.integer(gsub('(^[0-9]+)[+]([0-9]+$)', '\\\\2', Minute)), \n      NA_integer_\n    ),\n    is_home = Home_Away == 'Home',\n    team = Squad,\n    player = Player,\n    is_goal = Outcome == 'Goal',\n    xg = as.double(xG)\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(shots)\n#> Rows: 15,277\n#> Columns: 9\n#> $ match_id      <chr> \"48a684ed\", \"48a684ed\", \"48a684ed\", \"48a684ed\", \"48a6…\n#> $ period        <int> 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2,…\n#> $ minutes       <int> 6, 13, 31, 34, 45, 51, 73, 80, 83, 19, 30, 41, 45, 48…\n#> $ minutes_added <int> NA, NA, NA, NA, 1, NA, NA, NA, NA, NA, NA, NA, 2, NA,…\n#> $ is_home       <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,…\n#> $ team          <chr> \"Nashville\", \"Nashville\", \"Nashville\", \"Nashville\", \"…\n#> $ player        <chr> \"Jacob Shaffelburg\", \"Sean Davis\", \"Teal Bunbury\", \"W…\n#> $ is_goal       <lgl> FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE,…\n#> $ xg            <dbl> 0.39, 0.09, 0.03, 0.25, 0.04, 0.02, 0.02, 0.45, 0.04,…\n```\n:::\n\n\n### Accounting for Own goals\n\nNow, for the ugliest part of all this shot data wrangling--handling own goals.\n\nFirst, we inject \"synthetic\" records into the `shots` data for every case where the match summary indicates that there is an own goal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshots_with_own_goals <- dplyr::bind_rows(\n  shots |> \n    dplyr::transmute(\n      match_id,\n      period,\n      minutes,\n      minutes_added,\n      is_home,\n      team,\n      player,\n      is_goal,\n      xg,\n      is_own_goal = FALSE\n    ),\n  ## synthetic events for own goals\n  match_summaries |> \n    dplyr::filter(\n      is_own_goal\n    ) |> \n    dplyr::transmute(\n      match_id,\n      period,\n      minutes,\n      minutes_added,\n      is_home = team == home_team,\n      team,\n      player,\n      is_goal = TRUE,\n      xg = NA_real_,\n      is_own_goal = TRUE\n    )\n)\n```\n:::\n\n\nNext, we add proper, cleaned columns for goals and xG.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_shots <- shots_with_own_goals |> \n  ## To get meta-information about the game\n  dplyr::inner_join(\n    match_summaries |>\n      dplyr::distinct(match_id, home_team, away_team),\n    by = dplyr::join_by(match_id),\n    relationship = 'many-to-one'\n  ) |> \n  dplyr::mutate(\n    home_g = dplyr::case_when(\n      ## Note that fotmob would list the away team for an own goal but fbref \n      ##   lists the home team\n      (is_goal | is_own_goal) & is_home ~ 1L,\n      is_own_goal & is_home ~ 1L,\n      TRUE ~ 0L\n    ),\n    away_g = dplyr::case_when(\n      (is_goal | is_own_goal) & !is_home ~ 1L,\n      TRUE ~ 0L\n    ),\n    home_xg = dplyr::case_when(\n      is_home ~ dplyr::coalesce(xg, 0),\n      TRUE ~ 0L ## even for own goals\n    ),\n    away_xg = dplyr::case_when(\n      !is_home ~ dplyr::coalesce(xg, 0),\n      TRUE ~ 0L\n    )\n  ) |>\n  dplyr::group_by(match_id) |>\n  ## Differentiate between shots in the same minute.\n  dplyr::mutate(\n    shot_idx = dplyr::row_number((minutes + dplyr::coalesce(minutes_added, 0L)))\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::transmute(\n    shot_id = sprintf('%s-%02d', match_id, shot_idx),\n    match_id,\n    period,\n    minutes,\n    minutes_added,\n    is_home,\n    is_goal,\n    is_own_goal,\n    player,\n    home_team,\n    away_team,\n    home_g,\n    away_g,\n    home_xg,\n    away_xg\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(clean_shots)\n#> Rows: 15,335\n#> Columns: 15\n#> $ shot_id       <chr> \"48a684ed-01\", \"48a684ed-02\", \"48a684ed-05\", \"48a684e…\n#> $ match_id      <chr> \"48a684ed\", \"48a684ed\", \"48a684ed\", \"48a684ed\", \"48a6…\n#> $ period        <int> 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2,…\n#> $ minutes       <int> 6, 13, 31, 34, 45, 51, 73, 80, 83, 19, 30, 41, 45, 48…\n#> $ minutes_added <dbl> NA, NA, NA, NA, 1, NA, NA, NA, NA, NA, NA, NA, 2, NA,…\n#> $ is_home       <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,…\n#> $ is_goal       <lgl> FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE,…\n#> $ is_own_goal   <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS…\n#> $ player        <chr> \"Jacob Shaffelburg\", \"Sean Davis\", \"Teal Bunbury\", \"W…\n#> $ home_team     <chr> \"Nashville SC\", \"Nashville SC\", \"Nashville SC\", \"Nash…\n#> $ away_team     <chr> \"New York City FC\", \"New York City FC\", \"New York Cit…\n#> $ home_g        <int> 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ away_g        <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ home_xg       <dbl> 0.39, 0.09, 0.03, 0.25, 0.04, 0.02, 0.02, 0.45, 0.04,…\n#> $ away_xg       <dbl> 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,…\n```\n:::\n\n\n### Double Counting Shot Events\n\nUp to this point, we have one record per shot. But, to calculate goals and expected goals (xG) conceded for any given team at any given point in a game, we can make our lives easier by \"double counting\" each shot event, once from each team's perspective.\n\nTo do that, we first re-assign (\"re-stack\") teams and goals based on the home and away teams' perspectives.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestacked_shots <- dplyr::bind_rows(\n  clean_shots |> \n    dplyr::filter(is_home) |> \n    dplyr::transmute(\n      shot_id,\n      match_id,\n      period,\n      minutes,\n      minutes_added,\n      is_home,\n      is_goal,\n      is_own_goal,\n      player,\n      team = home_team,\n      opponent = away_team,\n      g = home_g,\n      g_conceded = away_g,\n      xg = home_xg,\n      xg_conceded = away_xg\n    ),\n  clean_shots |> \n    dplyr::filter(!is_home) |> \n    dplyr::transmute(\n      shot_id,\n      match_id,\n      period,\n      minutes,\n      minutes_added,\n      is_home,\n      is_goal,\n      is_own_goal,\n      player,\n      team = away_team,\n      opponent = home_team,\n      g = away_g,\n      g_conceded = home_g,\n      xg = away_xg,\n      xg_conceded = home_xg\n    )\n)\n```\n:::\n\n\nThen, we replicate the whole data frame, indicating whether we're looking at the shot events from a given team's **p**oint **o**f **v**iew (`pov = \"primary\"`) or their opponents' point of view (`\"secondary\"`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndoublecounted_restacked_shots <- dplyr::bind_rows(\n  restacked_shots |> dplyr::mutate(pov = 'primary', .before = 1),\n  restacked_shots |> \n    ## re-assign to temporary variable names first, so that way we don't accidentlaly overwrite information\n    dplyr::rename(\n      team1 = team,\n      team2 = opponent,\n      g1 = g,\n      g2 = g_conceded,\n      xg1 = xg,\n      xg2 = xg_conceded\n    ) |> \n    ## then formally re-assign columns\n    dplyr::rename(\n      team = team2,\n      opponent = team1,\n      g = g2,\n      g_conceded = g1,\n      xg = xg2,\n      xg_conceded = xg1\n    ) |> \n    dplyr::mutate(\n      is_home = !is_home\n    ) |> \n    dplyr::mutate(\n      pov = 'secondary',\n      .before = 1\n    )\n) |> \n  dplyr::arrange(match_id, shot_id, pov)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(doublecounted_restacked_shots)\n#> Rows: 30,670\n#> Columns: 16\n#> $ pov           <chr> \"primary\", \"secondary\", \"primary\", \"secondary\", \"prim…\n#> $ shot_id       <chr> \"00069d73-01\", \"00069d73-01\", \"00069d73-02\", \"00069d7…\n#> $ match_id      <chr> \"00069d73\", \"00069d73\", \"00069d73\", \"00069d73\", \"0006…\n#> $ period        <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n#> $ minutes       <int> 2, 2, 4, 4, 9, 9, 20, 20, 24, 24, 32, 32, 34, 34, 35,…\n#> $ minutes_added <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#> $ is_home       <lgl> TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, T…\n#> $ is_goal       <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS…\n#> $ is_own_goal   <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS…\n#> $ player        <chr> \"Hany Mukhtar\", \"Hany Mukhtar\", \"Teal Bunbury\", \"Teal…\n#> $ team          <chr> \"Nashville SC\", \"Chicago Fire\", \"Nashville SC\", \"Chic…\n#> $ opponent      <chr> \"Chicago Fire\", \"Nashville SC\", \"Chicago Fire\", \"Nash…\n#> $ g             <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ g_conceded    <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ xg            <dbl> 0.04, 0.00, 0.17, 0.00, 0.02, 0.00, 0.12, 0.00, 0.05,…\n#> $ xg_conceded   <dbl> 0.00, 0.04, 0.00, 0.17, 0.00, 0.02, 0.00, 0.12, 0.00,…\n```\n:::\n\n\n### Calculating Cumulative Goals\n\nNext, we calculate cumulative goals and xG scored and conceded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncumu_doublecounted_restacked_shots <- doublecounted_restacked_shots |> \n  dplyr::group_by(match_id, team) |> \n  dplyr::mutate(\n    dplyr::across(\n      c(g, g_conceded),\n      list(cumu = cumsum)\n    )\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::mutate(\n    gamestate = g_cumu - g_conceded_cumu\n  )\n```\n:::\n\n\nAnd then we bring everything together to create a singular data frame from which it is straightforward to calculate xGD with respect to game state.[^2]\n\n[^2]: Keep in mind that the xG associated with a shot that is scored and changes the game state should be associated with the pre-shot game state, not the post-shot game state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nORDERED_gamestate_LABELS <- c('Trailing', 'Tied', 'Leading')\ngamestate_shots <- cumu_doublecounted_restacked_shots |> \n  dplyr::inner_join(\n    match_summaries |> \n      dplyr::distinct(\n        match_id,\n        season,\n        date,\n        home_team,\n        away_team\n      ),\n    by = dplyr::join_by(match_id)\n  ) |> \n  dplyr::transmute(\n    pov,\n    match_id,\n    season,\n    date,\n    home_team,\n    away_team,\n    team,\n    player,\n    shot_id,\n    period,\n    minutes,\n    minutes_added,\n    time = minutes + dplyr::coalesce(minutes_added, 0L),\n    xg,\n    xgd = xg - xg_conceded,\n    gamestate = cut(\n      gamestate,\n      breaks = c(-Inf, -1, 0, Inf),\n      labels = ORDERED_gamestate_LABELS\n    )\n  ) |> \n  dplyr::group_by(match_id, team) |> \n  dplyr::arrange(shot_id, .by_group = TRUE) |> \n  dplyr::mutate(\n    pre_shot_gamestate = dplyr::lag(gamestate, default = ORDERED_gamestate_LABELS[2])\n  ) |> \n  dplyr::ungroup()\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(gamestate_shots)\n#> Rows: 30,670\n#> Columns: 17\n#> $ pov                <chr> \"secondary\", \"secondary\", \"secondary\", \"secondar…\n#> $ match_id           <chr> \"00069d73\", \"00069d73\", \"00069d73\", \"00069d73\", …\n#> $ season             <int> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, …\n#> $ date               <date> 2023-05-06, 2023-05-06, 2023-05-06, 2023-05-06,…\n#> $ home_team          <chr> \"Nashville SC\", \"Nashville SC\", \"Nashville SC\", …\n#> $ away_team          <chr> \"Chicago Fire\", \"Chicago Fire\", \"Chicago Fire\", …\n#> $ team               <chr> \"Chicago Fire\", \"Chicago Fire\", \"Chicago Fire\", …\n#> $ player             <chr> \"Hany Mukhtar\", \"Teal Bunbury\", \"Hany Mukhtar\", …\n#> $ shot_id            <chr> \"00069d73-01\", \"00069d73-02\", \"00069d73-03\", \"00…\n#> $ period             <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, …\n#> $ minutes            <int> 2, 4, 9, 20, 24, 32, 34, 35, 39, 40, 41, 42, 45,…\n#> $ minutes_added      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ time               <dbl> 2, 4, 9, 20, 24, 32, 34, 35, 39, 40, 41, 42, 45,…\n#> $ xg                 <dbl> 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, …\n#> $ xgd                <dbl> -0.04, -0.17, -0.02, -0.12, -0.05, -0.08, -0.04,…\n#> $ gamestate          <fct> Tied, Tied, Tied, Tied, Tied, Tied, Tied, Tied, …\n#> $ pre_shot_gamestate <fct> Tied, Tied, Tied, Tied, Tied, Tied, Tied, Tied, …\n```\n:::\n\n\n### Padding end-of-match events\n\nOh, wait! We should probably account for the amount of time spent in a game state when contextualizing xGD. To do that properly, we should add more synthetic records for the end of halves.\n\nUnfortunately, FBref does not provide the exact ending minute of each half, as far as I know. Thus, we'll \"pad\" our data with artificial records to mark the end of halves--the 45th minute in the first half / 90th minute in the second half--using some heuristics.\n\n1.  If there are no shots after the last regular minute in a half, we add 3 minutes. (3 minutes is about the median amount of minutes allocated for extra time.)\n2.  If the last shot is after the last regular minute in a half, we take the maximum of:\n    -   Adding 3 minutes beyond the last regular minute (like (1)) or\n    -   Adding one minute beyond the last shot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLAST_MIN_BUFFER <- 3\nlast_min_pad <- gamestate_shots |>\n  dplyr::select(\n    match_id,\n    season,\n    date,\n    team,\n    pre_shot_gamestate,\n    period,\n    time\n  ) |> \n  dplyr::group_by(match_id, team, period) |>\n  dplyr::slice_max(time, n = 1, with_ties = FALSE) |>\n  dplyr::ungroup() |>\n  dplyr::mutate(\n    xg = 0,\n    xgd = 0,\n    last_regular_min = ifelse(period == 1L, 45L, 90L),\n    time = pmax(last_regular_min + LAST_MIN_BUFFER, time + 1)\n  )\n\npadded_gamestate_shots <- dplyr::bind_rows(\n  gamestate_shots,\n  last_min_pad\n) |> \n  dplyr::arrange(match_id, time)\n\ngamestate_shots_and_durations <- padded_gamestate_shots |> \n  dplyr::group_by(match_id, team) |> \n  dplyr::mutate(\n    prev_period = dplyr::lag(period),\n    prev_time = dplyr::lag(time)\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::mutate(\n    duration = dplyr::case_when(\n      period == 1L & is.na(prev_period) ~ time - 0L,\n      period == 2L & period != prev_period ~ time - 45L,\n      TRUE ~ time - prev_time\n    )\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndplyr::glimpse(gamestate_shots_and_durations)\n#> Rows: 32,642\n#> Columns: 21\n#> $ pov                <chr> \"secondary\", \"primary\", \"secondary\", \"primary\", …\n#> $ match_id           <chr> \"00069d73\", \"00069d73\", \"00069d73\", \"00069d73\", …\n#> $ season             <int> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, …\n#> $ date               <date> 2023-05-06, 2023-05-06, 2023-05-06, 2023-05-06,…\n#> $ home_team          <chr> \"Nashville SC\", \"Nashville SC\", \"Nashville SC\", …\n#> $ away_team          <chr> \"Chicago Fire\", \"Chicago Fire\", \"Chicago Fire\", …\n#> $ team               <chr> \"Chicago Fire\", \"Nashville SC\", \"Chicago Fire\", …\n#> $ player             <chr> \"Hany Mukhtar\", \"Hany Mukhtar\", \"Teal Bunbury\", …\n#> $ shot_id            <chr> \"00069d73-01\", \"00069d73-01\", \"00069d73-02\", \"00…\n#> $ period             <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n#> $ minutes            <int> 2, 2, 4, 4, 9, 9, 20, 20, 24, 24, 32, 32, 34, 34…\n#> $ minutes_added      <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ time               <dbl> 2, 2, 4, 4, 9, 9, 20, 20, 24, 24, 32, 32, 34, 34…\n#> $ xg                 <dbl> 0.00, 0.04, 0.00, 0.17, 0.00, 0.02, 0.00, 0.12, …\n#> $ xgd                <dbl> -0.04, 0.04, -0.17, 0.17, -0.02, 0.02, -0.12, 0.…\n#> $ gamestate          <fct> Tied, Tied, Tied, Tied, Tied, Tied, Tied, Tied, …\n#> $ pre_shot_gamestate <fct> Tied, Tied, Tied, Tied, Tied, Tied, Tied, Tied, …\n#> $ last_regular_min   <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#> $ prev_period        <int> NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#> $ prev_time          <dbl> NA, NA, 2, 2, 4, 4, 9, 9, 20, 20, 24, 24, 32, 32…\n#> $ duration           <dbl> 2, 2, 2, 2, 5, 5, 11, 11, 4, 4, 8, 8, 2, 2, 1, 1…\n```\n:::\n\n\n## Data analysis\n\nAs the saying goes, \"80% of data analysis/science is data cleaning\". Well, that rings true here, as all we need to do at this point is perform a few common `{dplyr}` and `{tidyr}` actions to arrive at xGD by game state. Oh, and we should contextualize game state xGD by how long a team has spent in each game state (`duration`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nagg_gamestate_xgd <- gamestate_shots_and_durations |> \n  dplyr::group_by(team, pre_shot_gamestate) |> \n  dplyr::summarize(\n    dplyr::across(\n      c(\n        xgd,\n        duration\n      ),\n      \\(.x) sum(.x, na.rm = TRUE)\n    )\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::mutate(\n    xgd_p90 = xgd * 90 / duration\n  ) |> \n  dplyr::group_by(team) |> \n  dplyr::mutate(\n    prop_duration = duration / sum(duration)\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::select(\n    team,\n    pre_shot_gamestate,\n    xgd_p90,\n    prop_duration\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nagg_gamestate_xgd\n#> # A tibble: 87 × 4\n#>    team           pre_shot_gamestate  xgd_p90 prop_duration\n#>    <chr>          <fct>                 <dbl>         <dbl>\n#>  1 Atlanta United Trailing            0.277           0.266\n#>  2 Atlanta United Tied               -0.00208         0.385\n#>  3 Atlanta United Leading             0.262           0.350\n#>  4 Austin FC      Trailing            0.0287          0.271\n#>  5 Austin FC      Tied               -0.0978          0.508\n#>  6 Austin FC      Leading            -0.474           0.221\n#>  7 CF Montréal    Trailing           -1.20            0.376\n#>  8 CF Montréal    Tied               -0.388           0.400\n#>  9 CF Montréal    Leading             0.327           0.223\n#> 10 Charlotte FC   Trailing           -0.0656          0.212\n#> # ℹ 77 more rows\n```\n:::\n\n\nWe did all that work, so let's make a pretty graph that conveys both:\n\n1.  the proportion of time spent in a given game state, and\n2.  the xGD [per 90](https://statsbomb.com/articles/soccer/an-introduction-to-the-per-90-metric/) per game state\n\nfor every team. Keep in mind that an xGD per 90 of +0.50 means that you're accumulating half a goal's worth of shot quality more than you're giving up over the course of a game. While this number may seem small, that's quite a good number over the course of an entire season.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## logo scraping\nlibrary(httr)\nlibrary(jsonlite)\n\n## plotting\nlibrary(ggplot2)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(ggtext)\nlibrary(htmltools)\nlibrary(grid)\nlibrary(scales)\n\nTAG_LABEL <- htmltools::tagList(\n  htmltools::tags$span(htmltools::HTML(enc2utf8('&#xf099;')), style = 'font-family:fb'),\n  htmltools::tags$span('@TonyElHabr'),\n)\nCAPTION_LABEL <- '**Data**: Opta via fbref.'\nSUBTITLE_LABEL <- 'MLS, 2023 Season'\nPLOT_RESOLUTION <- 300\nWHITISH_FOREGROUND_COLOR <- 'white'\nCOMPLEMENTARY_FOREGROUND_COLOR <- '#cbcbcb'\nBLACKISH_BACKGROUND_COLOR <- '#1c1c1c'\nCOMPLEMENTARY_BACKGROUND_COLOR <- '#4d4d4d'\nFONT <- 'Titillium Web'\nsysfonts::font_add_google(FONT, FONT)\n## https://github.com/tashapiro/tanya-data-viz/blob/main/chatgpt-lensa/chatgpt-lensa.R for twitter logo\nsysfonts::font_add('fb', 'Font Awesome 6 Brands-Regular-400.otf')\nshowtext::showtext_auto()\nshowtext::showtext_opts(dpi = PLOT_RESOLUTION)\n\nggplot2::theme_set(ggplot2::theme_minimal())\nggplot2::theme_update(\n  text = ggplot2::element_text(family = FONT),\n  title = ggplot2::element_text(size = 20, color = WHITISH_FOREGROUND_COLOR),\n  plot.title = ggtext::element_markdown(face = 'bold', size = 20, color = WHITISH_FOREGROUND_COLOR),\n  plot.title.position = 'plot',\n  plot.subtitle = ggtext::element_markdown(size = 16, color = COMPLEMENTARY_FOREGROUND_COLOR),\n  axis.text = ggplot2::element_text(color = WHITISH_FOREGROUND_COLOR, size = 14),\n  axis.title.x = ggtext::element_markdown(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),\n  axis.title.y = ggtext::element_markdown(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0.99),\n  axis.line = ggplot2::element_blank(),\n  strip.text = ggplot2::element_text(size = 14, color = WHITISH_FOREGROUND_COLOR, face = 'bold', hjust = 0),\n  legend.position = 'top',\n  legend.text = ggplot2::element_text(size = 12, color = WHITISH_FOREGROUND_COLOR, face = 'plain'),\n  legend.title = ggplot2::element_text(size = 12, color = WHITISH_FOREGROUND_COLOR, face = 'bold'),\n  panel.grid.major = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),\n  panel.grid.minor = ggplot2::element_line(color = COMPLEMENTARY_BACKGROUND_COLOR),\n  panel.grid.minor.x = ggplot2::element_blank(),\n  panel.grid.minor.y = ggplot2::element_blank(),\n  plot.margin = ggplot2::margin(10, 20, 10, 20),\n  plot.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR),\n  plot.caption = ggtext::element_markdown(size = 10, color = WHITISH_FOREGROUND_COLOR, hjust = 0, face = 'plain'),\n  plot.caption.position = 'plot',\n  plot.tag = ggtext::element_markdown(size = 10, color = WHITISH_FOREGROUND_COLOR, hjust = 1),\n  plot.tag.position = c(0.99, 0.01),\n  panel.spacing.x = grid::unit(2, 'lines'),\n  panel.background = ggplot2::element_rect(fill = BLACKISH_BACKGROUND_COLOR, color = BLACKISH_BACKGROUND_COLOR)\n)\nggplot2::update_geom_defaults('text', list(color = WHITISH_FOREGROUND_COLOR, size = 12 / .pt))\n\nGAMESTATE_PAL <- c(\n  'Trailing' = '#ef3e36',\n  'Tied' = COMPLEMENTARY_FOREGROUND_COLOR,\n  'Leading' = '#17bebb'\n)\n\n## There is a way to get team logos from FBref, but they have a white background \n##   by default, and making the background transparent for a plot with a dark\n##   background is kind of a pain in the ass. So let's pull images from fotmob.\n## This function is basically a minified version of what used to exist as\n##   worldfootballR::fotmob_get_league_tables(). I rely on FBref and fotmob listing\n##   teams in the same order alphabetically, which works fine for the MLS. A\n##   better, scalable strategy for binding team names between sources is to\n##   order teams by points / placement in the standings.\n\nget_fotmob_mls_standings <- function() {\n  url <- 'https://www.fotmob.com/api/leagues?id=130'\n  resp <- httr::GET(url)\n  cont <- httr::content(resp, as = 'text')\n  result <- jsonlite::fromJSON(cont)\n  table_init <- result$table$data\n  tables <- dplyr::bind_rows(table_init$tables)\n  tables$table$all[[3]] |> \n    dplyr::transmute(\n      team = name,\n      team_id = id,\n      pts,\n      logo_url = sprintf('https://images.fotmob.com/image_resources/logo/teamlogo/%s.png', team_id)\n    )\n}\n\nfotmob_mls_standings <- get_fotmob_mls_standings()\nteam_logos <- agg_gamestate_xgd |> \n  dplyr::distinct(team) |> \n  dplyr::arrange(team) |> \n  ## Lucky for us, MLS team names line up with the fotmob names alphabetically.\n  dplyr::bind_cols(\n    fotmob_mls_standings |> \n      dplyr::arrange(team) |> \n      dplyr::select(path = logo_url, pts)\n  )\n\nagg_gamestate_xgd_with_logos <- agg_gamestate_xgd |> \n  dplyr::inner_join(\n    team_logos |> \n      dplyr::select(\n        team,\n        pts,\n        path\n      ),\n    by = dplyr::join_by(team)\n  ) |> \n  dplyr::mutate(\n    label = glue::glue(\"{team} <img src='{path}' width='15' height='15'/>\")\n  ) |> \n  dplyr::select(-path)\n\nagg_gamestate_xgd_with_logos |>\n  filter(pre_shot_gamestate == 'Tied') |> \n  mutate(\n    across(\n      c(prop_duration, pts, xgd_p90), \n      list(rnk = \\(.x) row_number(desc(.x)))\n    ),\n    d = prop_duration_rnk - pts_rnk\n  ) |> \n  arrange(\n    desc(abs(d))\n  )\n\nteam_label_order <- agg_gamestate_xgd_with_logos |> \n  dplyr::filter(\n    pre_shot_gamestate == 'Leading'\n  ) |> \n  dplyr::arrange(prop_duration) |> \n  dplyr::pull(team)\n\nprepped_agg_gamestate_xgd <- agg_gamestate_xgd_with_logos |> \n  dplyr::mutate(\n    dplyr::across(\n      team,\n      \\(.x) factor(.x, levels = team_label_order)\n    )\n  ) |> \n  dplyr::arrange(team, desc(pre_shot_gamestate)) |> \n  dplyr::group_by(team) |> \n  dplyr::mutate(\n    cumu_prop_duration = cumsum(prop_duration)\n  ) |> \n  dplyr::ungroup() |> \n  dplyr::mutate(\n    half_cumu_prop_duration = cumu_prop_duration - 0.5 * prop_duration\n  )\n\nxgd_p90_plot <- prepped_agg_gamestate_xgd |> \n  ggplot2::ggplot() +\n  ggplot2::aes(\n    x = prop_duration,\n    y = team\n  ) +\n  ggplot2::scale_y_discrete(\n    name = '',\n    labels = prepped_agg_gamestate_xgd |>\n      dplyr::distinct(team, label) |>\n      tibble::deframe()\n  ) +\n  ggplot2::theme(\n    axis.text.y = ggtext::element_markdown(margin = grid::unit(c(0, 0, 0, 0), 'pt')),\n  ) +\n  ggplot2::geom_col(\n    show.legend = FALSE,\n    alpha = 0.8,\n    ggplot2::aes(\n      fill = pre_shot_gamestate\n    )\n  ) +\n  ggplot2::geom_text(\n    family = FONT,\n    size = 12 / ggplot2::.pt,\n    fontface = 'bold',\n    color = WHITISH_FOREGROUND_COLOR,\n    data = dplyr::filter(prepped_agg_gamestate_xgd, xgd_p90 >= 0),\n    ggplot2::aes(\n      x = half_cumu_prop_duration,\n      y = team,\n      label = scales::number(xgd_p90, accuracy = 0.01, style_positive = 'plus')\n    )\n  ) +\n  ggplot2::geom_text(\n    family = FONT,\n    size = 12 / ggplot2::.pt,\n    fontface = 'bold.italic',\n    color = BLACKISH_BACKGROUND_COLOR,\n    data = dplyr::filter(prepped_agg_gamestate_xgd, xgd_p90 < 0),\n    ggplot2::aes(\n      x = half_cumu_prop_duration,\n      y = team,\n      label = scales::number(xgd_p90, accuracy = 0.01)\n    )\n  ) +\n  ggplot2::scale_x_continuous(\n    labels = scales::percent_format(accuracy = 1),\n    expand = c(0.01, 0.01)\n  ) +\n  ggplot2::scale_fill_manual(\n    values = GAMESTATE_PAL\n  ) +\n  ggplot2::theme(\n    panel.grid.major.y = ggplot2::element_blank(),\n    panel.grid.major.x = ggplot2::element_blank(),\n    legend.position = 'top'\n  ) +\n  ggplot2::labs(\n    title = glue::glue(\"(xG - xG Conceded) per 90 when <span style='color:{GAMESTATE_PAL[['Leading']]}'>Leading</span>, <span style='color:{GAMESTATE_PAL[['Tied']]}'>Tied</span>, and <span style='color:{GAMESTATE_PAL[['Trailing']]}'>Trailing</spna>\"),\n    subtitle = SUBTITLE_LABEL,\n    y = NULL,\n    tag = TAG_LABEL,\n    caption = CAPTION_LABEL,\n    x = '% of Match Time'\n  )\nxgd_p90_plot\n\nxgd_p90_plot_path <- file.path(PROJ_DIR, '2023-mls-xgd-p90.png')\nggplot2::ggsave(\n  xgd_p90_plot,\n  filename = xgd_p90_plot_path,\n  width = 8,\n  height = 8\n)\n\n## https://themockup.blog/posts/2019-01-09-add-a-logo-to-your-plot/\nadd_logo <- function(\n    plot_path,\n    logo_path,\n    logo_scale = 0.1,\n    idx_x = 0.01, ## right-hand side\n    idx_y = 0.99, ## top of plot\n    adjust_x = ifelse(idx_x < 0.5, TRUE, FALSE),\n    adjust_y = ifelse(idx_y < 0.5, TRUE, FALSE)\n) {\n  plot <- magick::image_read(plot_path)\n  logo_raw <- magick::image_read(logo_path)\n  \n  plot_height <- magick::image_info(plot)$height\n  plot_width <- magick::image_info(plot)$width\n  \n  logo <- magick::image_scale(\n    logo_raw,\n    as.character(round(plot_width * logo_scale))\n  )\n  \n  info <- magick::image_info(logo)\n  logo_width <- info$width\n  logo_height <- info$height\n  \n  x_pos <- plot_width - idx_x * plot_width\n  y_pos <- plot_height - idx_y * plot_height\n  \n  if (isTRUE(adjust_x)) {\n    x_pos <- x_pos - logo_width\n  }\n  \n  if (isTRUE(adjust_y)) {\n    y_pos <- y_pos - logo_height\n  }\n  \n  offset <- paste0('+', x_pos, '+', y_pos)\n  \n  new_plot <- magick::image_composite(plot, logo, offset = offset)\n  ext <- tools::file_ext(plot_path)\n  rgx_ext <- sprintf('[.]%s$', ext)\n  \n  magick::image_write(\n    new_plot,\n    plot_path\n  )\n}\n\nadd_logo(\n  xgd_p90_plot_path,\n  logo_path = file.path(PROJ_DIR, 'mls-logo-black-and-white.png'),\n  logo_scale = 0.06\n)\n```\n:::\n\n\n![](2023-mls-xgd-p90.png)\n\nSo, what can we learn from this perspective?\n\n1.  [Columbus](https://en.wikipedia.org/wiki/Columbus_Crew), who [finished](https://www.fotmob.com/leagues/130/overview/mls?season=2023) with the third most points, looks to be the most dominant team all-around. They have the most time spent leading (43%) and are one of only three teams with a positive xGD rate in every game state.\n2.  [Cincinnati](https://en.wikipedia.org/wiki/FC_Cincinnati)--the team that ended up with the most points in the regular season--is 11th in terms of time spent leading (30%). On the other hand, they do have the best xGD per 90 rate (+0.60) out of all teams in neutral (\"Tied\") game states, which is the most common game state on average.\n3.  [Orlando City](https://en.wikipedia.org/wiki/Orlando_City_SC), who finished with the second most points, has a relatively poor xGD rate in neutral game states (-0.21). This may be something to be concerned about it in the playoffs, where matches can be tighter.\n4.  [Sporting KC](https://en.wikipedia.org/wiki/Sporting_Kansas_City) has the fourth-most time spent leading (35%) and one of the better xGD rates when leading (+0.40), but ended up 8th in the Western Conference after accumulating just the 16th most points across all 29 teams. They could be a team to watch out for in the playoffs if they can get a lead early in their matches.\n\n## Conclusion\n\nAs we've seen, calculating stats with respect to game state using data from the biggest public provider of soccer info is... not exactly straightforward. But the additional layers of insights that we can glean from contextualizing with game state can be rewarding.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}